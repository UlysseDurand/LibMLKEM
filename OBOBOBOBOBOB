[1mdiff --git a/spark_ada/src/mlkem.adb b/spark_ada/src/mlkem.adb[m
[1mdeleted file mode 100644[m
[1mindex 75216fa..0000000[m
[1m--- a/spark_ada/src/mlkem.adb[m
[1m+++ /dev/null[m
[36m@@ -1,2280 +0,0 @@[m
[31m---  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.[m
[31m---  SPDX-License-Identifier: Apache-2.0[m
[31m-[m
[31m-with SHA3;  use SHA3;[m
[31m-with SHAKE; use SHAKE;[m
[31m-[m
[31m-with SPARK.Cut_Operations; use SPARK.Cut_Operations;[m
[31m-with SPARK.Big_Integers; use SPARK.Big_Integers;[m
[31m-with MyLemmas; use MyLemmas;[m
[31m-[m
[31m-package body MLKEM[m
[31m-  with SPARK_Mode => On[m
[31m-is[m
[31m-[m
[31m-[m
[31m-   --==============================================================================[m
[31m-   --  Notation, Naming and Operators[m
[31m-   --==============================================================================[m
[31m-   --[m
[31m-   --  This section lays out a few notational conventions for readers[m
[31m-   --  that might not be familiar with Ada or SPARK, and notes a few[m
[31m-   --  important differences between the notation used in FIPS 203 and[m
[31m-   --  that appearing here.[m
[31m-   --[m
[31m-   --  Assignment and Equality[m
[31m-   --  -----------------------[m
[31m-   --[m
[31m-   --  As in Pascal, SPARK uses ":=" for assignment and "=" for equality.[m
[31m-   --  The latter is predefined for most types, and always returns the predefined[m
[31m-   --  Boolean type. The "not equals" operator is denoted "/="[m
[31m-   --[m
[31m-   --  Concatenation[m
[31m-   --  -------------[m
[31m-   --[m
[31m-   --  FIPS 203 uses "||" for concatenation of sequences and/or arrays.[m
[31m-   --  In SPARK, all one-dimensional arrays have a predefined concatentation[m
[31m-   --  index operator, denoted "&".[m
[31m-   --[m
[31m-   --  Ranges and Array Slices[m
[31m-   --  -----------------------[m
[31m-   --[m
[31m-   --  Ranges of integers in SPARK (denoted "X .. Y") are _inclusive_[m
[31m-   --  at both ends. Similarly a "slice" of an array object, denoted[m
[31m-   --  A (X .. Y), is all the elements of A from the X'th to the Y'th[m
[31m-   --  element inclusive.[m
[31m-   --[m
[31m-   --  Naming[m
[31m-   --  ------[m
[31m-   --[m
[31m-   --  Where FIPS 203 uses accented characters such as the UNICODE code-point[m
[31m-   --  "Latin Capital A with Circumflex", this code uses a suffix on a simple[m
[31m-   --  name (e.g. "A_Hat" in this case) and sticks to the simple Latin_1 subset[m
[31m-   --  of the character set. Other than that, the code maintains the names of all[m
[31m-   --  types and variables from FIPS 203.[m
[31m-   --==============================================================================[m
[31m-[m
[31m-[m
[31m-[m
[31m-   --  GNATProve generates false-alarms for the gnatwa.t warning ("suspicious contracts")[m
[31m-   --  when instantiating generics owing to a defect in the compiler front-end in[m
[31m-   --  GNAT versions up to and including 13.1.0. This problem will be corrected in GNAT Pro 25.0[m
[31m-   --  (See AdaCore TN CS0037963)[m
[31m-   pragma Warnings (GNATprove, Off, "postcondition does not mention function result");[m
[31m-   pragma Warnings (GNATprove, Off, "conjunct in postcondition does not check the outcome");[m
[31m-[m
[31m-[m
[31m-   --=======================================[m
[31m-   --  Local constants and types[m
[31m-   --=======================================[m
[31m-[m
[31m-   --  Bytes_64 type is needed for SHA3[m
[31m-   subtype Index_64  is I32 range 0 .. 63;[m
[31m-   subtype Bytes_64  is Byte_Seq (Index_64);[m
[31m-[m
[31m-   subtype U8_Bit is Unsigned_8 range 0 .. 1;[m
[31m-[m
[31m-   package body Zq[m
[31m-     with SPARK_Mode => On[m
[31m-   is[m
[31m-      C      : constant := 2**37;[m
[31m-      Magic  : constant := C / Q;[m
[31m-[m
[31m-      function "+" (Left, Right : in T) return T[m
[31m-      is[m
[31m-         R      : I32;[m
[31m-         Reduce : I32;[m
[31m-      begin[m
[31m-         --  At -O0 and -Og, GCC typically generates a branch for a[m
[31m-         --  predefined modular "+" operator, so we code[m
[31m-         --  explicitly here for constant time[m
[31m-[m
[31m-         R := I32 (Left) + I32 (Right);[m
[31m-         pragma Assert (R >= 0 and R <= 2 * I32 (T'Last));[m
[31m-[m
[31m-         Reduce := Boolean'Pos (R >= Q);[m
[31m-[m
[31m-         R := R - (Reduce * Q);[m
[31m-[m
[31m-         --  Prove that we can safely convert the answer back to type T...[m
[31m-         pragma Assert (R >= 0 and R < Q);[m
[31m-         --  ... and that the answer is correct[m
[31m-         pragma Assert (R = (I32 (Left) + I32 (Right)) mod Q);[m
[31m-[m
[31m-         return T (R);[m
[31m-      end "+";[m
[31m-[m
[31m-      function "-" (Left, Right : in T) return T[m
[31m-      is[m
[31m-         R      : I32;[m
[31m-         Reduce : I32;[m
[31m-      begin[m
[31m-         R := I32 (Left) - I32 (Right);[m
[31m-         pragma Assert (R > -Q and R < Q); --  R in -3228 .. 3228[m
[31m-[m
[31m-         --  If R is negative, then we need to add Q, else add 0[m
[31m-         Reduce := Boolean'Pos (R < 0);[m
[31m-         R := R + (Reduce * Q);[m
[31m-[m
[31m-         --  Prove that we can safely convert the answer back to type T...[m
[31m-         pragma Assert (R >= 0 and R < Q);[m
[31m-         --  ... and that the answer is correct[m
[31m-         pragma Assert (R = (I32 (Left) - I32 (Right)) mod Q);[m
[31m-[m
[31m-         return T (R);[m
[31m-      end "-";[m
[31m-[m
[31m-      function I32_To_Big_Integer (A : I32) return Big_Integer is (To_Big_Integer (Integer(A))); [m
[31m-[m
[31m-      --  function Big_Integer_To_I32 (A : Big_Integer) return Integer is (I32 (From_Big_Integer (A))); [m
[31m-[m
[31m-      function "*" (Left, Right : in T) return T[m
[31m-      is[m
[31m-         subtype Zq_Product is I32 range 0 .. ((Q - 1) ** 2);[m
[31m-[m
[31m-         R1     : Zq_Product;[m
[31m-         R2     : I64;[m
[31m-[m
[31m-         TA, TB, R, R3, R4 : I32;[m
[31m-         BigTA, BigTB: Big_Integer;[m
[31m-      begin[m
[31m-         --  This implementation computes (Left * Right) mod Q[m
[31m-         --  using the Barrett/Montgomery reduction trick (See PLDI '94 for[m
[31m-         --  the gory details.)  Most compilers will do this automatically,[m
[31m-         --  but gcc -Os generates "divide" instructions which have variable[m
[31m-         --  time, so this is written out explicity here.[m
[31m-         --[m
[31m-         --  Essentially, to compute A mod Q, we want to do[m
[31m-         --    A mod Q = A - (A / Q) * Q, where "/" truncates towards zero[m
[31m-         --  To avoid the division operator, we can multiply by the reciprocal:[m
[31m-         --            = A - (A * (1 / Q)) * Q[m
[31m-         --  and then multiply both top and bottom of the division by a suitably[m
[31m-         --  large power of 2.  It turns about that 2**37 / Q = 41_285_357.1[m
[31m-         --  which is close enough that the integer value Magic = 41_285_357 can be used[m
[31m-         --  if Left and Right are both less than Q.[m
[31m-         --            = A - ((A * Magic) / 2**37) * Q[m
[31m-         --  We choose a power of 2, so that the division is now implemented by a shift-right.[m
[31m-[m
[31m-         --  Initial multiplication of Left * Right can be done using 32-bit maths[m
[31m-         --  with no chance of overflow, so...[m
[31m-         TA := I32 (Left);[m
[31m-         TB := I32 (Right);[m
[31m-         R1 := TA * TB;[m
[31m-[m
[31m-         pragma Assert (((R1 / Q) * Q) <= R1); --  L1[m
[31m-[m
[31m-[m
[31m-         --  === We prove L2 ===[m
[31m-[m
[31m-         --  We will use lemmas we've proved on Big_Integers to prove L2[m
[31m-         BigTA := I32_To_Big_Integer(TA);[m
[31m-         BigTB := I32_To_Big_Integer(TB);[m
[31m-[m
[31m-         --  We need Q to be prime[m
[31m-         pragma Assert (Is_Prime (BigQ));[m
[31m-[m
[31m-         --  We use the contraposition of the lemma MyLemmas.Lemma_Prime_Divides_Product[m
[31m-         pragma Assert ((if BigTA * BigTB mod BigQ = 0 then (Lemma_Prime_Divides_Product (BigTA, BigTB, BigQ))));[m
[31m-[m
[31m-         --  Here it is[m
[31m-         pragma Assert (if BigTA /= 0 and BigTB /= 0 then (BigTA * BigTB mod BigQ /= 0));[m
[31m-[m
[31m-         --  We get the Big_Integer version of L2 [m
[31m-         pragma Assert ((if BigTA /= 0 and BigTB /= 0 then ((BigTA * BigTB / BigQ) * BigQ /= BigTA * BigTB)));[m
[31m-         -- ======[m
[31m-[m
[31m-         pragma Assert ((if Left /= 0 and Right /= 0 then (((R1 / Q) * Q) /= R1))); -- L2[m
[31m-[m
[31m-         --  L1 and L2 combine to conclude[m
[31m-         pragma Assert ((if Left /= 0 and Right /= 0 then (((R1 / Q) * Q) < R1)));[m
[31m-[m
[31m-         --  We need to prove a lower bound on (R1 / Q) * Q[m
[31m-         pragma Assert ((if Left = 0 or Right = 0 then R1 = 0));[m
[31m-         pragma Assert ((if Left /= 0 and Right /= 0 then ((R1 / Q) * Q) + Q > R1));[m
[31m-[m
[31m-         --  Rearrange...[m
[31m-         pragma Assert ((if Left /= 0 and Right /= 0 then R1 < ((R1 / Q) * Q) + Q));[m
[31m-[m
[31m-         --  Multiply top and bottom of the division by C...[m
[31m-         pragma Assert (if Left /= 0 and Right /= 0 then R1 < I32 (Q + (((I64 (R1) * C) / (Q * C)) * Q)));[m
[31m-[m
[31m-         --  Rearrange..[m
[31m-         pragma Assert (if Left /= 0 and Right /= 0 then R1 < I32 (Q + (((I64 (R1) * (C / Q)) / C) * Q)));[m
[31m-[m
[31m-         --  R1 is less than 2**24, and Magic is a bit less than 2**25, so we need to[m
[31m-         --  switch to 64-bit arithmetic now.[m
[31m-         R2 := I64 (R1) * Magic;[m
[31m-[m
[31m-         --  Substitute R1 * (C / Q) = R1 * Magic = R2[m
[31m-         pragma Assert (if Left /= 0 and Right /= 0 then R1 < I32 (Q + ((R2 / C) * Q)));[m
[31m-[m
[31m-         --  Shift right by 37 bits, then switch back to 32 bit arithmetic from here on[m
[31m-         R3 := I32 (R2 / C);[m
[31m-[m
[31m-         --  Substitute R2 / C = R3[m
[31m-         pragma Assert (if Left /= 0 and Right /= 0 then R1 < I32 (Q + (R3 * Q)));[m
[31m-[m
[31m-         R4 := R3 * Q;[m
[31m-[m
[31m-         --  Substitute R3 * Q = R4[m
[31m-         pragma Assert (if Left = 0 or Right = 0 then R1 = 0 and R4 = 0);[m
[31m-         pragma Assert (if Left /= 0 and Right /= 0 then R1 < I32 (Q + R4));[m
[31m-[m
[31m-         --  and therefore R1 - R4 < Q[m
[31m-         R := R1 - R4;[m
[31m-         pragma Assert (if Left = 0 or Right = 0 then R = 0);[m
[31m-         pragma Assert (if Left /= 0 and Right /= 0 then R < Q);[m
[31m-         -- Finally, we can combine the two cases to conclude[m
[31m-         pragma Assert (R < Q);[m
[31m-[m
[31m-         --  so can be safely converted to type T,[m
[31m-         --  and the answer is correct[m
[31m-         pragma Assert (if Left = 0 or Right = 0 then R = 0);[m
[31m-         pragma Assert (if Left /= 0 and Right /= 0 then T (R) = T (R1 mod Q));[m
[31m-         pragma Assert (T (R) = T (R1 mod Q));[m
[31m-         return T (R);[m
[31m-      end "*";[m
[31m-[m
[31m-      function ModQ (X : in U16) return T[m
[31m-      is[m
[31m-         R, R1, R2, R3, R4 : U64;[m
[31m-      begin[m
[31m-         R1 := U64 (X);[m
[31m-[m
[31m-         --  We need to prove a lower bound on (R1 / Q) * Q[m
[31m-         pragma Assert (((R1 / Q) * Q) + Q >= R1);[m
[31m-[m
[31m-         --  Rearrange...[m
[31m-         pragma Assert (R1 <= Q + ((R1 / Q) * Q));[m
[31m-[m
[31m-         --  Multiply top and bottom of the division by C...[m
[31m-         pragma Assert (R1 <= Q + (((R1 * C) / (Q * C)) * Q));[m
[31m-[m
[31m-         --  Rearrange...[m
[31m-         pragma Assert (R1 <= Q + (((R1 * (C / Q)) / C) * Q));[m
[31m-[m
[31m-         R2 := R1 * Magic;[m
[31m-[m
[31m-         --  Substitute R1 * (C / Q) = R1 * Magic = R2[m
[31m-         pragma Assert (R1 <= Q + ((R2 / C) * Q));[m
[31m-[m
[31m-         R3 := R2 / C; --  shift right by 37 bits[m
[31m-[m
[31m-         --  Substitute R2 / C = R3[m
[31m-         pragma Assert (R1 <= Q + (R3 * Q));[m
[31m-[m
[31m-         R4 := R3 * Q;[m
[31m-[m
[31m-         --  Substitute R3 * Q = R4[m
[31m-         pragma Assert (R1 <= Q + R4);[m
[31m-[m
[31m-         --  and therefore R1 - R4 <= Q[m
[31m-         pragma Assert (R1 - R4 <= Q);[m
[31m-[m
[31m-         --  so can be safely converted to type T[m
[31m-         R := R1 - R4;[m
[31m-[m
[31m-         pragma Assert (R <= Q);[m
[31m-[m
[31m-         -- R is in 0 .. 3329 here, so we still need to reduce the case where[m
[31m-         -- R = 3329 -> 0 in constant time, so[m
[31m-         R := Boolean'Pos (R /= Q) * R;[m
[31m-[m
[31m-         pragma Assert (R < Q);[m
[31m-[m
[31m-         --  so can be safely converted to type T,[m
[31m-         --  and the answer is correct[m
[31m-         pragma Assert (T (R) = T (X mod Q));[m
[31m-         return T (R);[m
[31m-      end ModQ;[m
[31m-[m
[31m-      function Div2 (Right : in T) return T[m
[31m-      is[m
[31m-      begin[m
[31m-         --  Note that Interfaces.Shift_Right for U16 is intrinsic,[m
[31m-         --  so should generate exactly one instruction on most ISAs.[m
[31m-         return T (Shift_Right (U16 (Right), 1));[m
[31m-      end Div2;[m
[31m-[m
[31m-      function Lemma_Big_To_Zq_Morp (A : Big_Integer;[m
[31m-                                     B : Big_Integer) return Boolean[m
[31m-      is[m
[31m-         R1 : Big_Integer := A mod BigQ;[m
[31m-         K1 : Big_Integer := Corresp_Divid_One (A - R1, BigQ);[m
[31m-         R2 : Big_Integer := B mod BigQ;[m
[31m-         K2 : Big_Integer := Corresp_Divid_One (B - R2, BigQ);[m
[31m-      begin[m
[31m-         pragma Assert (Q * K1 + R1 = A);[m
[31m-         pragma Assert (Q * K2 + R2 = B);[m
[31m-         pragma Assert (Q * (Q * K1 * K2 + K1 * R2 + K2 * R1) + R1 * R2 = A * B);[m
[31m-         pragma Assert ((A * B) mod BigQ = (A mod BigQ) * (B mod BigQ) mod BigQ);[m
[31m-         pragma Assert (Big_To_Zq (A * B) = Big_To_Zq (A) * Big_To_Zq (B));[m
[31m-         return True;[m
[31m-      end Lemma_Big_To_Zq_Morp;[m
[31m-[m
[31m-      function Inverse (A : in T) return T[m
[31m-      is[m
[31m-         BigA : Big_Integer := Zq_To_Big (A);[m
[31m-         The_Gcd : Ext_cd := Ext_gcd (BigA, BigQ);[m
[31m-         Big_Res : Big_Integer := The_Gcd.U;[m
[31m-         Res : T;[m
[31m-      begin[m
[31m-         pragma Assert (By( Is_Prime (BigQ), Lemma_Q_Prime));[m
[31m-         pragma Assert (BiGA * Big_Res + BigQ * The_Gcd.V = The_Gcd.D);[m
[31m-         pragma Assert (The_Gcd.D = 1);[m
[31m-         pragma Assert ((BigA * Big_Res) mod BigQ = 1);[m
[31m-         pragma Assert (Big_To_Zq (BigA * Big_Res) = 1);[m
[31m-         pragma Assert (By (Big_To_Zq (BigA) * Big_To_Zq (Big_Res) = 1, Lemma_Big_To_Zq_Morp(BigA, Big_Res)));[m
[31m-         Res := Big_To_Zq (Big_Res);[m
[31m-         pragma Assert (Big_Res mod BigQ = Zq_To_Big(Res));[m
[31m-         pragma Assert (Big_To_Zq ( Zq_To_Big(A) * Zq_To_Big(Res)  ) = A * Res);[m
[31m-         pragma Assert (Big_To_Zq (BigA) * Res = 1);[m
[31m-         return Res;[m
[31m-      end Inverse;[m
[31m-[m
[31m-      --  This is the power function on T.[m
[31m-      function "**" (A : T ; B : Big_Natural) return T is[m
[31m-      (if B = 0 then 1 else A * ("**" (A, B - 1)) );[m
[31m-[m
[31m-   end Zq;[m
[31m-[m
[31m-   --  Make everything in Zq directly visible from here on[m
[31m-   use Zq;[m
[31m-[m
[31m-   subtype NTT_Len_Bit_Index is Natural range 0 .. 6;[m
[31m-   subtype NTT_Len_Power     is Natural range 1 .. 7;[m
[31m-   --  A power of 2 between 2 and 128. Used in NTT and NTT_Inv[m
[31m-   subtype Len_T is Index_256[m
[31m-      with Dynamic_Predicate => (for some I in NTT_Len_Power => Len_T = 2**I);[m
[31m-[m
[31m-   --  A power of 2 between 1 and 64. Used in NTT and NTT_Inv[m
[31m-   subtype Count_T is Index_256[m
[31m-      with Dynamic_Predicate => (for some I in NTT_Len_Bit_Index => Count_T = 2**I);[m
[31m-[m
[31m-   subtype Index_3   is I32 range 0 .. 2;[m
[31m-   subtype Index_8   is I32 range 0 .. 7;[m
[31m-   subtype Index_12  is I32 range 0 .. 11;[m
[31m-   subtype Index_384 is I32 range 0 .. 383;[m
[31m-   subtype Index_3072 is I32 range 0 .. 3071;[m
[31m-   subtype Index_Poly_UDU_Bytes is I32 range 0 .. ((N * DU * K) / 8 - 1);[m
[31m-   subtype Index_Poly_Zq_Vector_Bytes is I32 range 0 .. (384 * K - 1);[m
[31m-[m
[31m-   subtype Index_UDU_Bytes is I32 range 0 .. (N * DU) / 8 - 1;[m
[31m-   subtype Bytes_UDU is Byte_Seq (Index_UDU_Bytes);[m
[31m-[m
[31m-   subtype Index_UDV_Bytes is I32 range 0 .. (N * DV) / 8 - 1;[m
[31m-   subtype Bytes_UDV is Byte_Seq (Index_UDV_Bytes);[m
[31m-[m
[31m-   subtype Bytes_3   is Byte_Seq (Index_3);[m
[31m-   subtype Bytes_384 is Byte_Seq (Index_384);[m
[31m-[m
[31m-   subtype Poly_UDU_Bytes is Byte_Seq (Index_Poly_UDU_Bytes);[m
[31m-   subtype Poly_Zq_Vector_Bytes is Byte_Seq (Index_Poly_Zq_Vector_Bytes);[m
[31m-[m
[31m-   --  Array of bits, with each bit stored as a Byte, so[m
[31m-   --  ineffecient in terms of space[m
[31m-   type Bit_Seq is array (N32 range <>) of U8_Bit;[m
[31m-[m
[31m-   subtype Bits_12 is Bit_Seq (Index_12);[m
[31m-   subtype Bits_256 is Bit_Seq (Index_256);[m
[31m-   subtype Bits_3072 is Bit_Seq (Index_3072);[m
[31m-[m
[31m-   subtype Index_Bits_UDU is I32 range 0 .. (N * DU) - 1;[m
[31m-   subtype Bits_UDU is Bit_Seq (Index_Bits_UDU);[m
[31m-[m
[31m-   subtype Index_Bits_UDV is I32 range 0 .. (N * DV) - 1;[m
[31m-   subtype Bits_UDV is Bit_Seq (Index_Bits_UDV);[m
[31m-[m
[31m-   subtype Index_PRF_Eta_1_Bytes is I32 range 0 .. 64 * Eta_1 - 1;[m
[31m-   subtype PRF_Eta_1_Bytes is Byte_Seq (Index_PRF_Eta_1_Bytes);[m
[31m-[m
[31m-   subtype Index_PRF_Eta_2_Bytes is I32 range 0 .. 64 * Eta_2 - 1;[m
[31m-   subtype PRF_Eta_2_Bytes is Byte_Seq (Index_PRF_Eta_2_Bytes);[m
[31m-[m
[31m-   --------------------------------------------------[m
[31m-   --  Polynomials, plus Vectors and Matrices thereof[m
[31m-   --------------------------------------------------[m
[31m-[m
[31m-   --  A DU-bit unsigned, modular type, but stored[m
[31m-   --  in 16 bits[m
[31m-   type UDU is mod 2**DU[m
[31m-     with Object_Size => 16;[m
[31m-[m
[31m-   --  A DV-bit unsigned, modular type, but stored[m
[31m-   --  in 16 bits[m
[31m-   type UDV is mod 2**DV[m
[31m-     with Object_Size => 16;[m
[31m-[m
[31m-   type Poly_UDU is array (Index_256) of UDU;[m
[31m-   type Poly_UDV is array (Index_256) of UDV;[m
[31m-[m
[31m-   subtype Poly_Zq_Bit is Poly_Zq[m
[31m-     with Dynamic_Predicate =>[m
[31m-            (for all I in Poly_Zq_Bit'Range => Poly_Zq_Bit (I) in Zq_Bit);[m
[31m-[m
[31m-   Null_NTT_Poly_Zq : constant NTT_Poly_Zq := (others => 0);[m
[31m-[m
[31m-   type Poly_UDU_Vector is array (K_Range) of Poly_UDU;[m
[31m-[m
[31m-   ------------------[m
[31m-   --  PKE Keys[m
[31m-   ------------------[m
[31m-[m
[31m-   subtype PKE_Decryption_Key_Index is I32 range 0 .. (384 * K - 1);[m
[31m-   subtype PKE_Decryption_Key is Byte_Seq (PKE_Decryption_Key_Index);[m
[31m-[m
[31m-   subtype PKE_Encryption_Key is MLKEM_Encapsulation_Key;[m
[31m-[m
[31m-   type PKE_Key is record[m
[31m-      EK : PKE_Encryption_Key;[m
[31m-      DK : PKE_Decryption_Key;[m
[31m-   end record;[m
[31m-[m
[31m-[m
[31m-   --=======================================[m
[31m-   --  Local subprogram declarations[m
[31m-   --=======================================[m
[31m-[m
[31m-   ----------------------------------[m
[31m-   --  BitsToBytes and BytesToBits[m
[31m-   --  See FIPS 203 4.2.1, 755 - 763[m
[31m-   ----------------------------------[m
[31m-[m
[31m-   --  Algorithm 2[m
[31m-   --  BitsToBytes is generic here over its parameter and return types[m
[31m-   --  so that each instantiation of it has definite/constrained types.[m
[31m-   --  This avoids the need for unconstrained parameters and return types,[m
[31m-   --  and this avoids the need for secondary stack and/or heap usage[m
[31m-   --  at run-time.[m
[31m-   generic[m
[31m-      type Bits_Index is range <>;[m
[31m-      type Some_Bits is array (Bits_Index) of U8_Bit;[m
[31m-      type Bytes_Index is range <>;[m
[31m-      type Some_Bytes is array (Bytes_Index) of Byte;[m
[31m-   function Generic_BitsToBytes (B : in Some_Bits) return Some_Bytes[m
[31m-     with No_Inline,[m
[31m-          Global => null,[m
[31m-          Pre    => B'First = 0 and[m
[31m-                    B'Length >= 8 and   --  at least 1 byte's worth[m
[31m-                    B'Length mod 8 = 0, --  an exact multiple of 8 bits[m
[31m-          Post   => Generic_BitsToBytes'Result'First = 0 and[m
[31m-                    Generic_BitsToBytes'Result'Length * 8 = B'Length and[m
[31m-                    Generic_BitsToBytes'Result'Length = B'Length / 8;[m
[31m-[m
[31m-   --  Algorithm 3[m
[31m-   --  Similarly, BytesToBits is generic to avoid unconstrained types[m
[31m-   generic[m
[31m-      type Bytes_Index is range <>;[m
[31m-      type Some_Bytes is array (Bytes_Index) of Byte;[m
[31m-      type Bits_Index is range <>;[m
[31m-      type Some_Bits is array (Bits_Index) of U8_Bit;[m
[31m-   function Generic_BytesToBits (B : in Some_Bytes) return Some_Bits[m
[31m-     with No_Inline,[m
[31m-          Global => null,[m
[31m-          Pre    => B'First = 0 and[m
[31m-                    U32 (B'Length) <= U32 (I32'Last / 8),[m
[31m-          Post   => Generic_BytesToBits'Result'First = 0 and[m
[31m-                    Generic_BytesToBits'Result'Length = 8 * B'Length;[m
[31m-[m
[31m-   --=======================================[m
[31m-   --  Local subprogram bodies[m
[31m-   --=======================================[m
[31m-[m
[31m-   -----------------------------------------[m
[31m-   --  Basic mathematical operators on Zq.T,[m
[31m-   --  polynomials, plus vectors and[m
[31m-   --  matrices thereof[m
[31m-   -----------------------------------------[m
[31m-[m
[31m-   function "+" (Left, Right : in NTT_Poly_Zq) return NTT_Poly_Zq[m
[31m-     with No_Inline,[m
[31m-          Post => (for all I in Index_256 => "+"'Result (I) = (Left (I) + Right (I)));[m
[31m-[m
[31m-   function "+" (Left, Right : in NTT_Poly_Zq) return NTT_Poly_Zq[m
[31m-   is[m
[31m-      R : NTT_Poly_Zq with Relaxed_Initialization;[m
[31m-   begin[m
[31m-      for I in R'Range loop[m
[31m-         R (I) := Left (I) + Right (I); -- implicitly mod Q[m
[31m-         pragma Loop_Invariant[m
[31m-            (for all K in Index_256 range 0 .. I => R (K)'Initialized and then[m
[31m-                                                    R (K) = (Left (K) + Right (K)));[m
[31m-      end loop;[m
[31m-[m
[31m-      return R;[m
[31m-   end "+";[m
[31m-[m
[31m-[m
[31m-   function "+" (Left, Right : in Poly_Zq) return Poly_Zq[m
[31m-     with Post => ([m
[31m-      for all I in Index_256 => "+"'Result (I) = (Left (I) + Right (I))[m
[31m-      );[m
[31m-[m
[31m-   function "+" (Left, Right : in Poly_Zq) return Poly_Zq[m
[31m-   is[m
[31m-   begin[m
[31m-      return Poly_Zq (NTT_Poly_Zq (Left) + NTT_Poly_Zq (Right)); --  calls _memcpy()[m
[31m-   end "+";[m
[31m-[m
[31m-   function "-" (Left, Right : in Poly_Zq) return Poly_Zq[m
[31m-     with No_Inline,[m
[31m-          Post => (for all I in Index_256 => "-"'Result (I) = (Left (I) - Right (I)));[m
[31m-[m
[31m-   function "-" (Left, Right : in Poly_Zq) return Poly_Zq[m
[31m-   is[m
[31m-      R : Poly_Zq with Relaxed_Initialization;[m
[31m-   begin[m
[31m-      for I in R'Range loop[m
[31m-         R (I) := Left (I) - Right (I); -- implicitly mod Q[m
[31m-         pragma Loop_Invariant[m
[31m-            (for all K in Index_256 range 0 .. I => R (K)'Initialized and then[m
[31m-                                                    R (K) = (Left (K) - Right (K)));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end "-";[m
[31m-[m
[31m-   function "*" (left, Right : in Poly_Zq) return Poly_Zq[m
[31m-          ; [m
[31m-[m
[31m-   function "*" (Left, Right : in Poly_Zq) return Poly_Zq[m
[31m-   is[m
[31m-      Res : Poly_Zq := (others => 0);[m
[31m-      K : Index_256;[m
[31m-   begin[m
[31m-      for i in Index_256'Range loop[m
[31m-         for j in 0 .. i loop[m
[31m-            k := i-j;[m
[31m-            Res (i) := Res (i) + Left (j mod Index_256'Last) * Right (k mod Index_256'Last);[m
[31m-         end loop;[m
[31m-[m
[31m-         for j in i .. Index_256'Last + i loop[m
[31m-            k := Index_256'Last + i - j;[m
[31m-            Res (i) := Res (i) + Left (j mod Index_256'Last) * Right (k mod Index_256'Last);[m
[31m-         end loop;[m
[31m-      end loop; [m
[31m-      return Res;[m
[31m-   end "*";[m
[31m-[m
[31m-   function Degree_Zq (P : in Poly_Zq) return Index_256[m
[31m-      with Post => ([m
[31m-            (for all i in Degree_Zq'Result + 1 .. Index_256'Last => (P (i) = 0) ) and[m
[31m-            (Degree_Zq'Result = 0 or P (Degree_Zq'Result) /= 0) and[m
[31m-            (for all i in Index_256'Range => (if (P(i) /= 0) then Degree_Zq'Result >= i))[m
[31m-            --  (for all i in Index_256'Range => (if (for all j in i + 1 .. Index_256'Last => (P(i) = 0) ) then Degree_Zq'Result <= i))[m
[31m-         );[m
[31m-[m
[31m-   function Degree_Zq (P : in Poly_Zq) return Index_256[m
[31m-   is[m
[31m-      res : Index_256 := Index_256'Last;[m
[31m-   begin[m
[31m-      if P (res) = 0 then[m
[31m-         while res > 0 and P(res) = 0 loop[m
[31m-            pragma Loop_Invariant (res /=0 and P (res) = 0);[m
[31m-            pragma Loop_Invariant (for all i in res .. Index_256'Last => (P (i) = 0));[m
[31m-            --  pragma Loop_Invariant (for all i in res .. );[m
[31m-            res := res - 1;[m
[31m-         end loop;[m
[31m-      end if;[m
[31m-      return res;[m
[31m-   end Degree_Zq;[m
[31m-[m
[31m-   function Is_Poly_Nul (P : in Poly_Zq) return Boolean is (for all i in Index_256'Range => (P(i) = 0));[m
[31m-[m
[31m-   --  Returns (X^d - R)[m
[31m-   function Monome (D : Index_256 ; R : Zq.T) return Poly_Zq[m
[31m-      with Pre => D > 0,[m
[31m-           Post => Degree_Zq (Monome'Result) = D;[m
[31m-[m
[31m-   function Monome (D : Index_256 ; R : Zq.T) return Poly_Zq[m
[31m-   is[m
[31m-      Res : Poly_Zq := (others => 0);[m
[31m-      degRes : Index_256;[m
[31m-   begin [m
[31m-      Res (0) := -R;[m
[31m-      Res (D) := 1;[m
[31m-      degRes := Degree_Zq (Res);[m
[31m-      pragma Assert (degRes >= D);[m
[31m-      pragma Assert ( for all i in D + 1 .. Index_256'Last => (Res (i) = 0) );[m
[31m-      pragma Assert (degRes <= D);[m
[31m-      return Res;[m
[31m-   end Monome;[m
[31m-[m
[31m-   type resDivEuclidPoly is record M : Poly_Zq ; R : Poly_Zq ; end record;[m
[31m-[m
[31m-   function Lemma_Poly_Add_Minus (P, Q : in Poly_Zq) return Boolean[m
[31m-      with Post => Lemma_Poly_Add_Minus'Result and (P - Q + Q = P);[m
[31m-[m
[31m-   function Lemma_Poly_Add_Minus (P, Q : in Poly_Zq) return Boolean [m
[31m-   is [m
[31m-      R : Poly_Zq := P - Q; [m
[31m-      S : Poly_Zq := R + Q; [m
[31m-   begin [m
[31m-      pragma Assert (for all I in Index_256'Range => R (i) = P (i) - Q(i) );[m
[31m-      pragma Assert (for all I in Index_256'Range => S (i) = R (i) + Q(i) );[m
[31m-      pragma Assert (for all I in Index_256'Range => S (i) = P (i) - Q(i) + Q(i) );[m
[31m-      pragma Assert (S = P);[m
[31m-      return True;[m
[31m-   end Lemma_Poly_Add_Minus;[m
[31m-[m
[31m-   function Lemma_Poly_Mult_Distrib_Add (P, Q, R : in Poly_Zq) return Boolean[m
[31m-      with Post => Lemma_Poly_Mult_Distrib_Add'Result and [m
[31m-                   (R * P + R * Q) = R * (P + Q);[m
[31m-   function Lemma_Poly_Mult_Distrib_Add (P, Q, R : in Poly_Zq) return Boolean[m
[31m-   is[m
[31m-   begin[m
[31m-      pragma Assume (R * P + R * Q = R * (P + Q));[m
[31m-      return True;[m
[31m-   end Lemma_Poly_Mult_Distrib_Add;[m
[31m-[m
[31m-   function Lemma_Poly_Add_Associatif (P, Q, R : in Poly_Zq) return Boolean[m
[31m-      with Post => Lemma_Poly_Add_Associatif'Result and [m
[31m-                   (P + Q) + R = P + (Q + R);[m
[31m-[m
[31m-   function Lemma_Poly_Add_Associatif (P, Q, R : in Poly_Zq) return Boolean[m
[31m-   is[m
[31m-   begin[m
[31m-      pragma Assert (for all i in Index_256 => P (i) + (Q (i) + R (i)) = (P (i) + Q (i)) + R (i));[m
[31m-      return True;[m
[31m-   end Lemma_Poly_Add_Associatif;[m
[31m-[m
[31m-   PolyZero : constant Poly_Zq := (others => 0);[m
[31m-[m
[31m-   function Lemma_Zero_Absorbs (P : in Poly_Zq) return Boolean[m
[31m-      with Post => Lemma_Zero_Absorbs'Result and [m
[31m-                   P * PolyZero = PolyZero;[m
[31m-[m
[31m-   function Lemma_Zero_Absorbs (P : in Poly_Zq) return Boolean[m
[31m-   is[m
[31m-   begin[m
[31m-      pragma Assume (P * PolyZero = PolyZero);[m
[31m-      return True;[m
[31m-   end Lemma_Zero_Absorbs;[m
[31m-[m
[31m-   --  Divides P by Q[m
[31m-[m
[31m-   function DivPoly (P : in Poly_Zq;[m
[31m-                     Q : in Poly_Zq) return resDivEuclidPoly[m
[31m-      with Post => ([m
[31m-         DivPoly'Result.R + (Q * DivPoly'Result.M) = P and[m
[31m-         Degree_Zq (DivPoly'Result.R) < Degree_Zq (Q) [m
[31m-      );[m
[31m-[m
[31m-   function DivPoly (P : in Poly_Zq;[m
[31m-                     Q : in Poly_Zq) return resDivEuclidPoly[m
[31m-   is[m
[31m-      res : resDivEuclidPoly;[m
[31m-      degP : Index_256;[m
[31m-      degQ : Index_256;[m
[31m-      lilP : Poly_Zq;[m
[31m-      lilReduce : resDivEuclidPoly;[m
[31m-      term : Poly_Zq := (others => 0);[m
[31m-   begin[m
[31m-      degP := Degree_Zq (P);[m
[31m-      degQ := Degree_Zq (Q);[m
[31m-      if degQ > degP then [m
[31m-         res.M := PolyZero; res.R := P;[m
[31m-         pragma Assert (By((res.R + (Q * res.M) = P), Lemma_Zero_Absorbs (Q) ));[m
[31m-         pragma Assert (Degree_Zq (res.R) < Degree_Zq (Q) ); [m
[31m-      else [m
[31m-         term (degP - degQ) := 1;[m
[31m-         lilP := P - (Q * term);[m
[31m-         lilReduce := DivPoly (lilP, Q);[m
[31m-         pragma Assert (By (lilP + (Q * term) = P, Lemma_Poly_Add_Minus (P, Q * term)));[m
[31m-         pragma Assert ( (lilReduce.R +  (Q * lilReduce.M)) + (Q * term) = P);[m
[31m-         pragma Assert (By(lilReduce.R + ( (Q * lilReduce.M) + (Q * term) ) = P, Lemma_Poly_Add_Associatif (lilReduce.R, Q * lilReduce.M, Q * term)));[m
[31m-         pragma Assert (By ([m
[31m-            (Q * lilReduce.M) + (Q * term) = Q * (lilReduce.M + term),[m
[31m-            Lemma_Poly_Mult_Distrib_Add (lilReduce.M, term, Q)[m
[31m-         ));[m
[31m-         pragma Assert (lilReduce.R + (Q * (lilReduce.M + term)) = P);[m
[31m-         res.M := lilReduce.M + term;[m
[31m-         res.R := lilReduce.R;[m
[31m-         pragma Assert (res.R + (Q * res.M) = P);[m
[31m-      end if;[m
[31m-      return res;[m
[31m-   end DivPoly;[m
[31m-[m
[31m-   function "+" (Left, Right : in NTT_Poly_Zq_Vector) return NTT_Poly_Zq_Vector[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : NTT_Poly_Zq_Vector;[m
[31m-   begin[m
[31m-      for I in R'Range loop[m
[31m-         R (I) := Left (I) + Right (I);[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end "+";[m
[31m-[m
[31m-   function "+" (Left, Right : in Poly_Zq_Vector) return Poly_Zq_Vector[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_Zq_Vector;[m
[31m-   begin[m
[31m-      for I in R'Range loop[m
[31m-         R (I) := Left (I) + Right (I);[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end "+";[m
[31m-[m
[31m-[m
[31m-   --  All elements of Left, multiplied by Right (mod q)[m
[31m-   function "*" (Left  : in Poly_Zq;[m
[31m-                 Right : in Zq.T) return Poly_Zq[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_Zq;[m
[31m-   begin[m
[31m-      for I in R'Range loop[m
[31m-         R (I) := Left (I) * Right; --  implicitly mod q[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end "*";[m
[31m-[m
[31m-   ----------------------------------[m
[31m-   --  Pseudo-Random Function[m
[31m-   --  See FIPS 203 4.1, 726 - 731[m
[31m-   ----------------------------------[m
[31m-[m
[31m-   function PRF_Eta_1 (S : in Bytes_32;[m
[31m-                       B : in Byte) return PRF_Eta_1_Bytes[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      C : SHAKE256.Context;[m
[31m-      R : PRF_Eta_1_Bytes;[m
[31m-   begin[m
[31m-      SHAKE256.Init (C);[m
[31m-      SHAKE256.Update (C, SHAKE256.Byte_Array (S & B));[m
[31m-      SHAKE256.Extract (C, SHAKE256.Byte_Array (R));[m
[31m-      pragma  Unreferenced (C);[m
[31m-      return R;[m
[31m-   end PRF_Eta_1;[m
[31m-[m
[31m-   function PRF_Eta_2 (S : in Bytes_32;[m
[31m-                       B : in Byte) return PRF_Eta_2_Bytes[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      C : SHAKE256.Context;[m
[31m-      R : PRF_Eta_2_Bytes;[m
[31m-   begin[m
[31m-      SHAKE256.Init (C);[m
[31m-      SHAKE256.Update (C, SHAKE256.Byte_Array (S & B));[m
[31m-      SHAKE256.Extract (C, SHAKE256.Byte_Array (R));[m
[31m-      pragma  Unreferenced (C);[m
[31m-      return R;[m
[31m-   end PRF_Eta_2;[m
[31m-[m
[31m-   --  The function XOF is declared below[m
[31m-   --  as part of Algorithm 6[m
[31m-[m
[31m-   ----------------------------------[m
[31m-   --  Hash functions, built on SHA3[m
[31m-   --  See FIPS 203 4.1, 741 - 750[m
[31m-   ----------------------------------[m
[31m-[m
[31m-   --  G returns a (32 bytes) followed by b (32 bytes)[m
[31m-   --  concatenated into 64 bytes.[m
[31m-   function G (C : in Byte_Seq) return Bytes_64[m
[31m-     with No_Inline,[m
[31m-          Global => null,[m
[31m-          Pre    => C'First = 0 and[m
[31m-                    C'Last <= I32 (Natural'Last - 1)[m
[31m-   is[m
[31m-      Ctx : SHA3_512.Context;[m
[31m-      R   : SHA3_512.Digest_Type;[m
[31m-   begin[m
[31m-      SHA3_512.Init (Ctx);[m
[31m-      SHA3_512.Update (Ctx, SHA3_512.Byte_Array (C));[m
[31m-      SHA3_512.Final (Ctx, R);[m
[31m-      pragma  Unreferenced (Ctx);[m
[31m-      return Bytes_64 (R);[m
[31m-   end G;[m
[31m-[m
[31m-   function H (C : in Byte_Seq) return Bytes_32[m
[31m-     with No_Inline,[m
[31m-          Global => null,[m
[31m-          Pre    => C'First = 0 and[m
[31m-                    C'Last <= I32 (Natural'Last - 1)[m
[31m-   is[m
[31m-      Ctx : SHA3_256.Context;[m
[31m-      R   : SHA3_256.Digest_Type;[m
[31m-   begin[m
[31m-      SHA3_256.Init (Ctx);[m
[31m-      SHA3_256.Update (Ctx, SHA3_256.Byte_Array (C));[m
[31m-      SHA3_256.Final (Ctx, R);[m
[31m-      pragma  Unreferenced (Ctx);[m
[31m-      return Bytes_32 (R);[m
[31m-   end H;[m
[31m-[m
[31m-   function J (C : in Byte_Seq) return Bytes_32[m
[31m-     with No_Inline,[m
[31m-          Global => null,[m
[31m-          Pre    => C'First = 0 and[m
[31m-                    C'Last <= I32 (Natural'Last - 1)[m
[31m-   is[m
[31m-      Ctx : SHAKE256.Context;[m
[31m-      R   : Bytes_32;[m
[31m-   begin[m
[31m-      SHAKE256.Init (Ctx);[m
[31m-      SHAKE256.Update (Ctx, SHAKE256.Byte_Array (C));[m
[31m-      SHAKE256.Extract (Ctx, SHAKE256.Byte_Array (R));[m
[31m-      pragma  Unreferenced (Ctx);[m
[31m-      return R;[m
[31m-   end J;[m
[31m-[m
[31m-[m
[31m-[m
[31m-[m
[31m-   function Generic_BitsToBytes (B : in Some_Bits) return Some_Bytes[m
[31m-   is[m
[31m-      R : Some_Bytes := Some_Bytes'(others => 0); --  calls _memset()[m
[31m-   begin[m
[31m-      for I in B'Range loop[m
[31m-         R (Bytes_Index (I / 8)) := R (Bytes_Index (I / 8)) +[m
[31m-                                    B (I) * (2 ** Natural (I mod 8));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end Generic_BitsToBytes;[m
[31m-[m
[31m-[m
[31m-   function Generic_BytesToBits (B : in Some_Bytes) return Some_Bits[m
[31m-   is[m
[31m-      R : Some_Bits := (others => 0); --  calls _memset()[m
[31m-      This_Byte : Byte;[m
[31m-   begin[m
[31m-      for I in B'Range loop[m
[31m-         This_Byte := B (I);[m
[31m-         for J in Index_8 loop[m
[31m-            R (8 * Bits_Index (I) + Bits_Index (J)) := This_Byte mod 2;[m
[31m-            This_Byte := This_Byte / 2;[m
[31m-         end loop;[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end Generic_BytesToBits;[m
[31m-[m
[31m-   -------------------------------------------------------[m
[31m-   --  Compression and Decompression[m
[31m-   --  Each function is declared overloaded several times[m
[31m-   --  for specific values of d and parameter types[m
[31m-   -------------------------------------------------------[m
[31m-[m
[31m-   --  Barrett reduction constants used below[m
[31m-   Q_C : constant := 43;[m
[31m-   Q_M : constant := 2_642_262_849; --  round (2**Q_C / Q);[m
[31m-[m
[31m-   function Compress1 (X : in Zq.T) return U8_Bit[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      T : U64;[m
[31m-   begin[m
[31m-      T := U64 (X) * 4 + Q;[m
[31m-[m
[31m-      --  Division by (Q * 2) is first achieved by dividing by 2[m
[31m-      T := T / 2;[m
[31m-      --  Then multiplication by Q_M and a shift right by Q_C places[m
[31m-      T := T * Q_M;[m
[31m-      T := Shift_Right (T, Q_C);[m
[31m-[m
[31m-      --  T might be in 0 .. 2 here, so a final reduction mod 2 is required[m
[31m-      T := T mod 2;[m
[31m-      return U8_Bit (T);[m
[31m-   end Compress1;[m
[31m-[m
[31m-   function Compress1 (X : in Poly_Zq) return Bits_256[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Bits_256;[m
[31m-   begin[m
[31m-      for I in X'Range loop[m
[31m-         R (I) := Compress1 (X (I));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end Compress1;[m
[31m-[m
[31m-   function CompressDV (X : in Zq.T) return UDV[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      C : constant := UDV'Modulus;[m
[31m-      T : U64;[m
[31m-   begin[m
[31m-      --  Add Q to the top-line, so that subsequent truncating division[m
[31m-      --  by 2Q is effectively "round to nearest"[m
[31m-      --    round-to-nearest(CX / Q) =[m
[31m-      --    floor((CX + 0.5Q)/Q) =[m
[31m-      --    floor((2CX + Q)/2Q)[m
[31m-      T := U64 (X) * 2 * C + Q;[m
[31m-[m
[31m-      --  Division by (Q * 2) is first achieved by dividing by 2[m
[31m-      T := T / 2;[m
[31m-      --  Then multiplication by Q_M and a shift right by Q_C places[m
[31m-      T := T * Q_M;[m
[31m-      T := Shift_Right (T, Q_C);[m
[31m-[m
[31m-      --  To return a value in UDV, an explicit reduction is[m
[31m-      --  required here. This is missing in FIPS-203 Eq 4.5[m
[31m-      T := T mod C;[m
[31m-      return UDV (T);[m
[31m-   end CompressDV;[m
[31m-[m
[31m-   function CompressDV (V : in Poly_Zq) return Poly_UDV[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_UDV;[m
[31m-   begin[m
[31m-      for I in V'Range loop[m
[31m-         R (I) := CompressDV (V (I));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end CompressDV;[m
[31m-[m
[31m-   function CompressDU (X : in Zq.T) return UDU[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      C : constant := UDU'Modulus;[m
[31m-      T : U64;[m
[31m-   begin[m
[31m-      T := U64 (X) * 2 * C + Q;[m
[31m-[m
[31m-      --  Division by (Q * 2) is first achieved by dividing by 2[m
[31m-      T := T / 2;[m
[31m-      --  Then multiplication by Q_M and a shift right by Q_C places[m
[31m-      T := T * Q_M;[m
[31m-      T := Shift_Right (T, Q_C);[m
[31m-[m
[31m-      --  To return a value in UDV, an explicit reduction is[m
[31m-      --  required here. This is missing in FIPS-203 Eq 4.5[m
[31m-      T := T mod C;[m
[31m-      return UDU (T);[m
[31m-   end CompressDU;[m
[31m-[m
[31m-   function CompressDU (V : in Poly_Zq) return Poly_UDU[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_UDU;[m
[31m-   begin[m
[31m-      for I in V'Range loop[m
[31m-         R (I) := CompressDU (V (I));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end CompressDU;[m
[31m-[m
[31m-   function CompressDU (V : in Poly_Zq_Vector) return Poly_UDU_Vector[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_UDU_Vector;[m
[31m-   begin[m
[31m-      for I in V'Range loop[m
[31m-         R (I) := CompressDU (V (I));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end CompressDU;[m
[31m-[m
[31m-   function Decompress1 (Y : in U8_Bit) return Zq.T[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      subtype RT is I32 range 0 .. 1665;[m
[31m-      T : RT;[m
[31m-   begin[m
[31m-      --  Round (Q / 2) = 1665[m
[31m-      --  0 -> 0[m
[31m-      --  1 -> 1665[m
[31m-      --  but implement in constant-time[m
[31m-      T := RT (Y) * 1665;[m
[31m-      return Zq.T (T);[m
[31m-   end Decompress1;[m
[31m-[m
[31m-   --  Decompress a vector of Zq_Bit values[m
[31m-   function Decompress1 (Y : in Poly_Zq_Bit) return Poly_Zq[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_Zq;[m
[31m-   begin[m
[31m-      for I in R'Range loop[m
[31m-         R (I) := Decompress1 (U8_Bit (Y (I)));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end Decompress1;[m
[31m-[m
[31m-   function DecompressDV (Y : in UDV) return Zq.T[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      C      : constant := 2**DV;[m
[31m-      Half_C : constant := C / 2;[m
[31m-      subtype Int_T is I32 range 0 .. (Q * I32 (UDV'Last) + Half_C);[m
[31m-      T : Int_T;[m
[31m-   begin[m
[31m-      T := Q * I32 (Y) + Half_C;[m
[31m-      T := T / C;[m
[31m-[m
[31m-      pragma Assert (T >= 0);[m
[31m-      pragma Assert (T < Q);[m
[31m-      return Zq.T (T);[m
[31m-   end DecompressDV;[m
[31m-[m
[31m-   function DecompressDV (Y : in Poly_UDV) return Poly_Zq[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_Zq;[m
[31m-   begin[m
[31m-      for I in R'Range loop[m
[31m-         R (I) := DecompressDV (Y (I));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end DecompressDV;[m
[31m-[m
[31m-   function DecompressDU (Y : in UDU) return Zq.T[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      C : constant := UDU'Modulus;[m
[31m-      Half_C : constant := C / 2;[m
[31m-[m
[31m-      subtype Int_T is I32 range 0 .. (Q * I32 (UDU'Last) + Half_C);[m
[31m-      T : Int_T;[m
[31m-   begin[m
[31m-      T := Q * I32 (Y) + Half_C;[m
[31m-      T := T / C;[m
[31m-[m
[31m-      pragma Assert (T >= 0);[m
[31m-      pragma Assert (T < Q);[m
[31m-      return Zq.T (T);[m
[31m-   end DecompressDU;[m
[31m-[m
[31m-   function DecompressDU (Y : in Poly_UDU) return Poly_Zq[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_Zq;[m
[31m-   begin[m
[31m-      for I in R'Range loop[m
[31m-         R (I) := DecompressDU (Y (I));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end DecompressDU;[m
[31m-[m
[31m-   --  Overloaded. Applies DecompressDU to all elements of V[m
[31m-   function DecompressDU (V : in Poly_UDU_Vector) return Poly_Zq_Vector[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_Zq_Vector;[m
[31m-   begin[m
[31m-      for I in K_Range loop[m
[31m-         R (I) := DecompressDU (V (I));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end DecompressDU;[m
[31m-[m
[31m-   -------------------------------------------------------[m
[31m-   --  Byte Encoding (Algorithm 4) and Decoding (Algorithm 5)[m
[31m-   --  Each function is declared overloaded several times[m
[31m-   --  for specific values of d and parameter types.[m
[31m-   -------------------------------------------------------[m
[31m-[m
[31m-   --  256 1-bit digits is 256 bits, which is 32 bytes[m
[31m-   function ByteEncode1 (F : in Bits_256) return Bytes_32[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      function BitsToBytes is new Generic_BitsToBytes[m
[31m-        (Index_256, Bits_256, Index_32, Bytes_32);[m
[31m-   begin[m
[31m-      return BitsToBytes (F);[m
[31m-   end ByteEncode1;[m
[31m-[m
[31m-   function ByteEncodeDV (F : in Poly_UDV) return Bytes_UDV[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Bytes_UDV;[m
[31m-      B : Bits_UDV := (others => 0); --  calls _memset()[m
[31m-      A : UDV;[m
[31m-      This_Bit : UDV;[m
[31m-[m
[31m-      function BitsToBytes is new Generic_BitsToBytes[m
[31m-        (Index_Bits_UDV, Bits_UDV, Index_UDV_Bytes, Bytes_UDV);[m
[31m-   begin[m
[31m-      for I in F'Range loop[m
[31m-         A := F (I);[m
[31m-[m
[31m-         for J in I32 range 0 .. DV - 1 loop[m
[31m-            This_Bit := A mod 2;[m
[31m-            B (I * DV + J) := U8_Bit (This_Bit);[m
[31m-            A := (A - This_Bit) / 2;[m
[31m-         end loop;[m
[31m-      end loop;[m
[31m-[m
[31m-      pragma Assert (B'Length = N * DV);[m
[31m-      R := BitsToBytes (B);[m
[31m-      return R;[m
[31m-   end ByteEncodeDV;[m
[31m-[m
[31m-   function ByteEncodeDU (F : in Poly_UDU) return Bytes_UDU[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Bytes_UDU;[m
[31m-      B : Bits_UDU := (others => 0); --  calls _memset()[m
[31m-      A : UDU;[m
[31m-      This_Bit : UDU;[m
[31m-[m
[31m-      function BitsToBytes is new Generic_BitsToBytes[m
[31m-        (Index_Bits_UDU, Bits_UDU, Index_UDU_Bytes, Bytes_UDU);[m
[31m-   begin[m
[31m-      for I in F'Range loop[m
[31m-         A := F (I);[m
[31m-[m
[31m-         for J in I32 range 0 .. DU - 1 loop[m
[31m-            This_Bit := A mod 2;[m
[31m-            B (I * DU + J) := U8_Bit (This_Bit);[m
[31m-            A := (A - This_Bit) / 2;[m
[31m-         end loop;[m
[31m-[m
[31m-      end loop;[m
[31m-      pragma Assert (B'Length = N * DU);[m
[31m-      R := BitsToBytes (B);[m
[31m-      return R;[m
[31m-   end ByteEncodeDU;[m
[31m-[m
[31m-[m
[31m-   function ByteEncodeDU (F : in Poly_UDU_Vector) return Poly_UDU_Bytes[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_UDU_Bytes with Relaxed_Initialization;[m
[31m-      C : constant I32 := (N * DU) / 8;[m
[31m-   begin[m
[31m-      for I in K_Range loop[m
[31m-         R (I32 (I) * C .. (I32 (I) + 1) * C - 1) := ByteEncodeDU (F (I));[m
[31m-         pragma Loop_Invariant (R (0 .. (I32 (I) + 1) * C - 1)'Initialized);[m
[31m-      end loop;[m
[31m-[m
[31m-      --  Substitute K for I + 1 in the loop invariant to get...[m
[31m-      pragma Assert (R (0 .. (K * C - 1))'Initialized);[m
[31m-      --  ...and therefore...[m
[31m-      pragma Assert (R'Initialized);[m
[31m-      return R;[m
[31m-   end ByteEncodeDU;[m
[31m-[m
[31m-[m
[31m-   function Bits_12_To_U16 (X : in Bits_12) return U16[m
[31m-   is (U16 (X (0)) +[m
[31m-       U16 (X (1)) * 2 +[m
[31m-       U16 (X (2)) * 4 +[m
[31m-       U16 (X (3)) * 8 +[m
[31m-       U16 (X (4)) * 16 +[m
[31m-       U16 (X (5)) * 32 +[m
[31m-       U16 (X (6)) * 64 +[m
[31m-       U16 (X (7)) * 128 +[m
[31m-       U16 (X (8)) * 256 +[m
[31m-       U16 (X (9)) * 512 +[m
[31m-       U16 (X (10)) * 1024 +[m
[31m-       U16 (X (11)) * 2048)[m
[31m-     with Ghost,[m
[31m-          Post => Bits_12_To_U16'Result < 4096;[m
[31m-[m
[31m-   function Zq_To_Bits_12 (X : in Zq.T) return Bits_12[m
[31m-     with Post => Bits_12_To_U16 (Zq_To_Bits_12'Result) < Q[m
[31m-   is[m
[31m-      T : constant U16 := U16 (X);[m
[31m-   begin[m
[31m-      pragma Assert (T < Q);[m
[31m-      return Bits_12'(0  => U8_Bit (T and 1),[m
[31m-                      1  => U8_Bit (Shift_Right (T, 1) and 1),[m
[31m-                      2  => U8_Bit (Shift_Right (T, 2) and 1),[m
[31m-                      3  => U8_Bit (Shift_Right (T, 3) and 1),[m
[31m-                      4  => U8_Bit (Shift_Right (T, 4) and 1),[m
[31m-                      5  => U8_Bit (Shift_Right (T, 5) and 1),[m
[31m-                      6  => U8_Bit (Shift_Right (T, 6) and 1),[m
[31m-                      7  => U8_Bit (Shift_Right (T, 7) and 1),[m
[31m-                      8  => U8_Bit (Shift_Right (T, 8) and 1),[m
[31m-                      9  => U8_Bit (Shift_Right (T, 9) and 1),[m
[31m-                      10 => U8_Bit (Shift_Right (T, 10) and 1),[m
[31m-                      11 => U8_Bit (Shift_Right (T, 11) and 1));[m
[31m-   end Zq_To_Bits_12;[m
[31m-[m
[31m-   function ByteEncode12 (F : in NTT_Poly_Zq) return Bytes_384[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Bytes_384;[m
[31m-      B : Bits_3072 := (others => 0); --  calls _memset()[m
[31m-[m
[31m-      function BitsToBytes is new Generic_BitsToBytes[m
[31m-        (Index_3072, Bits_3072, Index_384, Bytes_384);[m
[31m-   begin[m
[31m-      for I in F'Range loop[m
[31m-         B (I * 12 .. I * 12 + 11) := Zq_To_Bits_12 (F (I));[m
[31m-         pragma Assert (Bits_12_To_U16 (B (I * 12 .. I * 12 + 11)) < Q);[m
[31m-         pragma Loop_Invariant[m
[31m-           (for all K in Index_256 range 0 .. I =>[m
[31m-             (Bits_12_To_U16 (B (K * 12 .. K * 12 + 11)) < Q));[m
[31m-      end loop;[m
[31m-[m
[31m-      pragma Assert[m
[31m-        (for all K in Index_256 =>[m
[31m-          (Bits_12_To_U16 (B (K * 12 .. K * 12 + 11)) < Q));[m
[31m-[m
[31m-      R := BitsToBytes (B);[m
[31m-      return R;[m
[31m-   end ByteEncode12;[m
[31m-[m
[31m-   --  Overloaded. Applies ByteEncode12 to all elements of V[m
[31m-   function ByteEncode12 (V : in NTT_Poly_Zq_Vector) return Poly_Zq_Vector_Bytes[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_Zq_Vector_Bytes with Relaxed_Initialization;[m
[31m-   begin[m
[31m-      for I in K_Range loop[m
[31m-         R (I32 (I) * 384 .. I32 (I) * 384 + 383) := ByteEncode12 (V (I));[m
[31m-         pragma Loop_Invariant (R (0 .. I32 (I) * 384 + 383)'Initialized);[m
[31m-      end loop;[m
[31m-[m
[31m-      pragma Assert (R'Initialized);[m
[31m-      return R;[m
[31m-   end ByteEncode12;[m
[31m-[m
[31m-   function ByteDecode1 (B : in Bytes_32) return Poly_Zq_Bit[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      function BytesToBits is new Generic_BytesToBits[m
[31m-        (Index_32, Bytes_32, Index_256, Bits_256);[m
[31m-[m
[31m-      Bits : constant Bits_256 := BytesToBits (B);[m
[31m-      F : Poly_Zq_Bit := (others => 0); --  calls _memset()[m
[31m-   begin[m
[31m-      for I in F'Range loop[m
[31m-         F (I) := Zq_Bit (Bits (I));[m
[31m-         pragma Loop_Invariant (for all K in 0 .. I => F (K) in Zq_Bit);[m
[31m-      end loop;[m
[31m-      pragma Assert (F in Poly_Zq_Bit);[m
[31m-      return F;[m
[31m-   end ByteDecode1;[m
[31m-[m
[31m-   function ByteDecodeDV (B : in Bytes_UDV) return Poly_UDV[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      function BytesToBits is new Generic_BytesToBits[m
[31m-        (Index_UDV_Bytes, Bytes_UDV, Index_Bits_UDV, Bits_UDV);[m
[31m-[m
[31m-      Bits : constant Bits_UDV := BytesToBits (B);[m
[31m-      F : Poly_UDV;[m
[31m-      T : U16;[m
[31m-[m
[31m-   begin[m
[31m-      for I in F'Range loop[m
[31m-         T := 0;[m
[31m-         for Bit in I32 range 0 .. DV - 1 loop[m
[31m-            T := T + U16 (Bits (I * DV + Bit)) * 2**Natural (Bit);[m
[31m-            pragma Loop_Invariant (T >= 0);[m
[31m-            pragma Loop_Invariant (T <= 2**Natural (Bit + 1) - 1);[m
[31m-         end loop;[m
[31m-         F (I) := UDV (T);[m
[31m-      end loop;[m
[31m-      return F;[m
[31m-   end ByteDecodeDV;[m
[31m-[m
[31m-   function ByteDecodeDU (B : in Bytes_UDU) return Poly_UDU[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      function BytesToBits is new Generic_BytesToBits[m
[31m-        (Index_UDU_Bytes, Bytes_UDU, Index_Bits_UDU, Bits_UDU);[m
[31m-[m
[31m-      Bits : constant Bits_UDU := BytesToBits (B);[m
[31m-      F : Poly_UDU;[m
[31m-      T : U16;[m
[31m-   begin[m
[31m-      for I in F'Range loop[m
[31m-         T := 0;[m
[31m-         for Bit in I32 range 0 .. DU - 1 loop[m
[31m-            T := T + U16 (Bits (I * DU + Bit)) * 2**Natural (Bit);[m
[31m-            pragma Loop_Invariant (T >= 0);[m
[31m-            pragma Loop_Invariant (T <= 2**Natural (Bit + 1) - 1);[m
[31m-         end loop;[m
[31m-         F (I) := UDU (T);[m
[31m-      end loop;[m
[31m-      return F;[m
[31m-   end ByteDecodeDU;[m
[31m-[m
[31m-   function ByteDecodeDU (B : in Poly_UDU_Bytes) return Poly_UDU_Vector[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_UDU_Vector;[m
[31m-   begin[m
[31m-      for I in K_Range loop[m
[31m-         R (I) := ByteDecodeDU (B (I32 (I) * 32 * DU ..[m
[31m-                                  (I32 (I) + 1) * 32 * DU - 1));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end ByteDecodeDU;[m
[31m-[m
[31m-   function ByteDecode12 (B : in Bytes_384) return NTT_Poly_Zq[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      function BytesToBits is new Generic_BytesToBits[m
[31m-        (Index_384, Bytes_384, Index_3072, Bits_3072);[m
[31m-[m
[31m-      Bits : constant Bits_3072 := BytesToBits (B);[m
[31m-      F : NTT_Poly_Zq;[m
[31m-      T : U16;[m
[31m-   begin[m
[31m-      for I in F'Range loop[m
[31m-         T := U16 (Bits (I * 12)) +[m
[31m-              U16 (Bits (I * 12 + 1)) * 2 +[m
[31m-              U16 (Bits (I * 12 + 2)) * 4 +[m
[31m-              U16 (Bits (I * 12 + 3)) * 8 +[m
[31m-              U16 (Bits (I * 12 + 4)) * 16 +[m
[31m-              U16 (Bits (I * 12 + 5)) * 32 +[m
[31m-              U16 (Bits (I * 12 + 6)) * 64 +[m
[31m-              U16 (Bits (I * 12 + 7)) * 128 +[m
[31m-              U16 (Bits (I * 12 + 8)) * 256 +[m
[31m-              U16 (Bits (I * 12 + 9)) * 512 +[m
[31m-              U16 (Bits (I * 12 + 10)) * 1024 +[m
[31m-              U16 (Bits (I * 12 + 11)) * 2048;[m
[31m-         F (I) := ModQ (T);[m
[31m-      end loop;[m
[31m-      return F;[m
[31m-   end ByteDecode12;[m
[31m-[m
[31m-   function ByteDecode12 (B : in Poly_Zq_Vector_Bytes) return NTT_Poly_Zq_Vector[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : NTT_Poly_Zq_Vector;[m
[31m-   begin[m
[31m-      for I in K_Range loop[m
[31m-         R (I) := ByteDecode12 (B (384 * I32 (I) .. 384 * I32 (I) + 383));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end ByteDecode12;[m
[31m-[m
[31m-   ----------------------------------[m
[31m-   --  NTT, NTT_Inv and Sampling[m
[31m-   ----------------------------------[m
[31m-[m
[31m-   type Zeta_Exp_Table_Type is array (SU7) of Zq.T;[m
[31m-[m
[31m-   type Gamma_Table_Type is array (Index_128) of Zq.T;[m
[31m-[m
[31m-   --  This table generated by MLKEM.Tests.Gen_Zeta_Exp_Table procedure[m
[31m-   Zeta_ExpC : constant Zeta_Exp_Table_Type :=[m
[31m-     (0 => 1,[m
[31m-      1 => 1729,[m
[31m-      2 => 2580,[m
[31m-      3 => 3289,[m
[31m-      4 => 2642,[m
[31m-      5 => 630,[m
[31m-      6 => 1897,[m
[31m-      7 => 848,[m
[31m-      8 => 1062,[m
[31m-      9 => 1919,[m
[31m-      10 => 193,[m
[31m-      11 => 797,[m
[31m-      12 => 2786,[m
[31m-      13 => 3260,[m
[31m-      14 => 569,[m
[31m-      15 => 1746,[m
[31m-      16 => 296,[m
[31m-      17 => 2447,[m
[31m-      18 => 1339,[m
[31m-      19 => 1476,[m
[31m-      20 => 3046,[m
[31m-      21 => 56,[m
[31m-      22 => 2240,[m
[31m-      23 => 1333,[m
[31m-      24 => 1426,[m
[31m-      25 => 2094,[m
[31m-      26 => 535,[m
[31m-      27 => 2882,[m
[31m-      28 => 2393,[m
[31m-      29 => 2879,[m
[31m-      30 => 1974,[m
[31m-      31 => 821,[m
[31m-      32 => 289,[m
[31m-      33 => 331,[m
[31m-      34 => 3253,[m
[31m-      35 => 1756,[m
[31m-      36 => 1197,[m
[31m-      37 => 2304,[m
[31m-      38 => 2277,[m
[31m-      39 => 2055,[m
[31m-      40 => 650,[m
[31m-      41 => 1977,[m
[31m-      42 => 2513,[m
[31m-      43 => 632,[m
[31m-      44 => 2865,[m
[31m-      45 => 33,[m
[31m-      46 => 1320,[m
[31m-      47 => 1915,[m
[31m-      48 => 2319,[m
[31m-      49 => 1435,[m
[31m-      50 => 807,[m
[31m-      51 => 452,[m
[31m-      52 => 1438,[m
[31m-      53 => 2868,[m
[31m-      54 => 1534,[m
[31m-      55 => 2402,[m
[31m-      56 => 2647,[m
[31m-      57 => 2617,[m
[31m-      58 => 1481,[m
[31m-      59 => 648,[m
[31m-      60 => 2474,[m
[31m-      61 => 3110,[m
[31m-      62 => 1227,[m
[31m-      63 => 910,[m
[31m-      64 => 17,[m
[31m-      65 => 2761,[m
[31m-      66 => 583,[m
[31m-      67 => 2649,[m
[31m-      68 => 1637,[m
[31m-      69 => 723,[m
[31m-      70 => 2288,[m
[31m-      71 => 1100,[m
[31m-      72 => 1409,[m
[31m-      73 => 2662,[m
[31m-      74 => 3281,[m
[31m-      75 => 233,[m
[31m-      76 => 756,[m
[31m-      77 => 2156,[m
[31m-      78 => 3015,[m
[31m-      79 => 3050,[m
[31m-      80 => 1703,[m
[31m-      81 => 1651,[m
[31m-      82 => 2789,[m
[31m-      83 => 1789,[m
[31m-      84 => 1847,[m
[31m-      85 => 952,[m
[31m-      86 => 1461,[m
[31m-      87 => 2687,[m
[31m-      88 => 939,[m
[31m-      89 => 2308,[m
[31m-      90 => 2437,[m
[31m-      91 => 2388,[m
[31m-      92 => 733,[m
[31m-      93 => 2337,[m
[31m-      94 => 268,[m
[31m-      95 => 641,[m
[31m-      96 => 1584,[m
[31m-      97 => 2298,[m
[31m-      98 => 2037,[m
[31m-      99 => 3220,[m
[31m-      100 => 375,[m
[31m-      101 => 2549,[m
[31m-      102 => 2090,[m
[31m-      103 => 1645,[m
[31m-      104 => 1063,[m
[31m-      105 => 319,[m
[31m-      106 => 2773,[m
[31m-      107 => 757,[m
[31m-      108 => 2099,[m
[31m-      109 => 561,[m
[31m-      110 => 2466,[m
[31m-      111 => 2594,[m
[31m-      112 => 2804,[m
[31m-      113 => 1092,[m
[31m-      114 => 403,[m
[31m-      115 => 1026,[m
[31m-      116 => 1143,[m
[31m-      117 => 2150,[m
[31m-      118 => 2775,[m
[31m-      119 => 886,[m
[31m-      120 => 1722,[m
[31m-      121 => 1212,[m
[31m-      122 => 1874,[m
[31m-      123 => 1029,[m
[31m-      124 => 2110,[m
[31m-      125 => 2935,[m
[31m-      126 => 885,[m
[31m-      127 => 2154);[m
[31m-[m
[31m-   --  This table generated by MLKEM.Tests.Gen_Gamma_Table procedure[m
[31m-   Gamma_Table : constant Gamma_Table_Type :=[m
[31m-     (0 => 17,[m
[31m-      1 => 3312,[m
[31m-      2 => 2761,[m
[31m-      3 => 568,[m
[31m-      4 => 583,[m
[31m-      5 => 2746,[m
[31m-      6 => 2649,[m
[31m-      7 => 680,[m
[31m-      8 => 1637,[m
[31m-      9 => 1692,[m
[31m-      10 => 723,[m
[31m-      11 => 2606,[m
[31m-      12 => 2288,[m
[31m-      13 => 1041,[m
[31m-      14 => 1100,[m
[31m-      15 => 2229,[m
[31m-      16 => 1409,[m
[31m-      17 => 1920,[m
[31m-      18 => 2662,[m
[31m-      19 => 667,[m
[31m-      20 => 3281,[m
[31m-      21 => 48,[m
[31m-      22 => 233,[m
[31m-      23 => 3096,[m
[31m-      24 => 756,[m
[31m-      25 => 2573,[m
[31m-      26 => 2156,[m
[31m-      27 => 1173,[m
[31m-      28 => 3015,[m
[31m-      29 => 314,[m
[31m-      30 => 3050,[m
[31m-      31 => 279,[m
[31m-      32 => 1703,[m
[31m-      33 => 1626,[m
[31m-      34 => 1651,[m
[31m-      35 => 1678,[m
[31m-      36 => 2789,[m
[31m-      37 => 540,[m
[31m-      38 => 1789,[m
[31m-      39 => 1540,[m
[31m-      40 => 1847,[m
[31m-      41 => 1482,[m
[31m-      42 => 952,[m
[31m-      43 => 2377,[m
[31m-      44 => 1461,[m
[31m-      45 => 1868,[m
[31m-      46 => 2687,[m
[31m-      47 => 642,[m
[31m-      48 => 939,[m
[31m-      49 => 2390,[m
[31m-      50 => 2308,[m
[31m-      51 => 1021,[m
[31m-      52 => 2437,[m
[31m-      53 => 892,[m
[31m-      54 => 2388,[m
[31m-      55 => 941,[m
[31m-      56 => 733,[m
[31m-      57 => 2596,[m
[31m-      58 => 2337,[m
[31m-      59 => 992,[m
[31m-      60 => 268,[m
[31m-      61 => 3061,[m
[31m-      62 => 641,[m
[31m-      63 => 2688,[m
[31m-      64 => 1584,[m
[31m-      65 => 1745,[m
[31m-      66 => 2298,[m
[31m-      67 => 1031,[m
[31m-      68 => 2037,[m
[31m-      69 => 1292,[m
[31m-      70 => 3220,[m
[31m-      71 => 109,[m
[31m-      72 => 375,[m
[31m-      73 => 2954,[m
[31m-      74 => 2549,[m
[31m-      75 => 780,[m
[31m-      76 => 2090,[m
[31m-      77 => 1239,[m
[31m-      78 => 1645,[m
[31m-      79 => 1684,[m
[31m-      80 => 1063,[m
[31m-      81 => 2266,[m
[31m-      82 => 319,[m
[31m-      83 => 3010,[m
[31m-      84 => 2773,[m
[31m-      85 => 556,[m
[31m-      86 => 757,[m
[31m-      87 => 2572,[m
[31m-      88 => 2099,[m
[31m-      89 => 1230,[m
[31m-      90 => 561,[m
[31m-      91 => 2768,[m
[31m-      92 => 2466,[m
[31m-      93 => 863,[m
[31m-      94 => 2594,[m
[31m-      95 => 735,[m
[31m-      96 => 2804,[m
[31m-      97 => 525,[m
[31m-      98 => 1092,[m
[31m-      99 => 2237,[m
[31m-      100 => 403,[m
[31m-      101 => 2926,[m
[31m-      102 => 1026,[m
[31m-      103 => 2303,[m
[31m-      104 => 1143,[m
[31m-      105 => 2186,[m
[31m-      106 => 2150,[m
[31m-      107 => 1179,[m
[31m-      108 => 2775,[m
[31m-      109 => 554,[m
[31m-      110 => 886,[m
[31m-      111 => 2443,[m
[31m-      112 => 1722,[m
[31m-      113 => 1607,[m
[31m-      114 => 1212,[m
[31m-      115 => 2117,[m
[31m-      116 => 1874,[m
[31m-      117 => 1455,[m
[31m-      118 => 1029,[m
[31m-      119 => 2300,[m
[31m-      120 => 2110,[m
[31m-      121 => 1219,[m
[31m-      122 => 2935,[m
[31m-      123 => 394,[m
[31m-      124 => 885,[m
[31m-      125 => 2444,[m
[31m-      126 => 2154,[m
[31m-      127 => 1175);[m
[31m-[m
[31m-[m
[31m-[m
[31m-   --  Algorithm 6 - SampleNTT and XOF[m
[31m-   --  For this implementation, we combine XOF and SampleNTT[m
[31m-   --  into a single function. This avoids the need for XOF[m
[31m-   --  to return an unbounded sequence of bytes and/or some[m
[31m-   --  sort of lazy evaluation of an infinite sequence.[m
[31m-   function XOF_Then_SampleNTT (Rho : in Bytes_32;[m
[31m-                                I   : in Byte;[m
[31m-                                J   : in Byte) return NTT_Poly_Zq[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      C  : SHAKE128.Context;[m
[31m-      J2 : Natural := 0;[m
[31m-      A  : NTT_Poly_Zq := (others => 0); --  calls _memset()[m
[31m-      B  : Bytes_3;[m
[31m-   begin[m
[31m-      --  Initialize and feed input data into the XOF function[m
[31m-      --  which is actually SHAKE128[m
[31m-      SHAKE128.Init (C);[m
[31m-      SHAKE128.Update (C, SHAKE128.Byte_Array (Rho & I & J));[m
[31m-[m
[31m-      while J2 < 256 loop[m
[31m-         --  To execute this loop body once, we need exactly 3 bytes of output[m
[31m-         --  from the XOF function, so we fetch that many, and keep[m
[31m-         --  looping until the sampling terminates[m
[31m-         SHAKE128.Extract (C, SHAKE128.Byte_Array (B));[m
[31m-         declare[m
[31m-            D1  : constant U16 := U16 (B (0)) + (256 * (U16 (B (1)) mod 16));[m
[31m-            D2  : constant U16 := U16 (B (1)) / 16 + (16 * U16 (B (2)));[m
[31m-         begin[m
[31m-            if D1 < Q then[m
[31m-               A (Index_256 (J2)) := Zq.T (D1);[m
[31m-               J2 := J2 + 1;[m
[31m-            end if;[m
[31m-            if D2 < Q and J2 < 256 then[m
[31m-               A (Index_256 (J2)) := Zq.T (D2);[m
[31m-               J2 := J2 + 1;[m
[31m-            end if;[m
[31m-         end;[m
[31m-      end loop;[m
[31m-      return A;[m
[31m-   end XOF_Then_SampleNTT;[m
[31m-[m
[31m-[m
[31m-   --  Algorithm 7 - SamplePolyCBD2, specialized for Eta_1[m
[31m-   function SamplePolyCBD_Eta_1 (B : in PRF_Eta_1_Bytes) return Poly_Zq[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      subtype Index_PRF_Eta_1_Bits is I32 range 0 .. 8 * 64 * Eta_1 - 1;[m
[31m-      subtype PRF_Eta_1_Bits is Bit_Seq (Index_PRF_Eta_1_Bits);[m
[31m-[m
[31m-      function BytesToBits is new Generic_BytesToBits[m
[31m-        (Index_PRF_Eta_1_Bytes, PRF_Eta_1_Bytes,[m
[31m-         Index_PRF_Eta_1_Bits, PRF_Eta_1_Bits);[m
[31m-[m
[31m-      SB : constant PRF_Eta_1_Bits := BytesToBits (B);[m
[31m-      F  : Poly_Zq;[m
[31m-[m
[31m-      subtype Bit_Sum is Natural range 0 .. Eta_1;[m
[31m-[m
[31m-      function Sum_X (I : in Index_256) return Bit_Sum[m
[31m-        with No_Inline,[m
[31m-             Global => SB[m
[31m-      is[m
[31m-         R : Bit_Sum := 0;[m
[31m-      begin[m
[31m-         for J in Index_PRF_Eta_1_Bytes range 0 .. Eta_1 - 1 loop[m
[31m-            pragma Loop_Invariant (R >= 0);[m
[31m-            pragma Loop_Invariant (R <= Natural (J));[m
[31m-            R := R + Natural (SB (2 * I * Eta_1 + J));[m
[31m-         end loop;[m
[31m-         return R;[m
[31m-      end Sum_X;[m
[31m-[m
[31m-      function Sum_Y (I : in Index_256) return Bit_Sum[m
[31m-        with No_Inline,[m
[31m-             Global => SB[m
[31m-      is[m
[31m-         R : Bit_Sum := 0;[m
[31m-      begin[m
[31m-         for J in Index_PRF_Eta_1_Bytes range 0 .. Eta_1 - 1 loop[m
[31m-            pragma Loop_Invariant (R >= 0);[m
[31m-            pragma Loop_Invariant (R <= Natural (J));[m
[31m-            R := R + Natural (SB (2 * I * Eta_1 + Eta_1 + J));[m
[31m-         end loop;[m
[31m-         return R;[m
[31m-      end Sum_Y;[m
[31m-[m
[31m-   begin[m
[31m-      for I in Index_256 loop[m
[31m-         declare[m
[31m-            X : constant Bit_Sum := Sum_X (I);[m
[31m-            Y : constant Bit_Sum := Sum_Y (I);[m
[31m-         begin[m
[31m-            --  This "-" _is_ modulo Q[m
[31m-            F (I) := Zq.T (X) - Zq.T (Y); --  implicitly mod Q[m
[31m-         end;[m
[31m-      end loop;[m
[31m-      return F;[m
[31m-   end SamplePolyCBD_Eta_1;[m
[31m-[m
[31m-   --  Algorithm 7 - SamplePolyCBD2, specialized for Eta_2[m
[31m-   function SamplePolyCBD_Eta_2 (B : in PRF_Eta_2_Bytes) return Poly_Zq[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      subtype Index_PRF_Eta_2_Bits is I32 range 0 .. 8 * 64 * Eta_2 - 1;[m
[31m-      subtype PRF_Eta_2_Bits is Bit_Seq (Index_PRF_Eta_2_Bits);[m
[31m-[m
[31m-      function BytesToBits is new Generic_BytesToBits[m
[31m-        (Index_PRF_Eta_2_Bytes, PRF_Eta_2_Bytes,[m
[31m-         Index_PRF_Eta_2_Bits, PRF_Eta_2_Bits);[m
[31m-[m
[31m-      SB : constant PRF_Eta_2_Bits := BytesToBits (B);[m
[31m-      F  : Poly_Zq;[m
[31m-[m
[31m-      subtype Bit_Sum is Natural range 0 .. Eta_2;[m
[31m-[m
[31m-      function Sum_X (I : in Index_256) return Bit_Sum[m
[31m-        with No_Inline,[m
[31m-             Global => SB[m
[31m-      is[m
[31m-         R : Bit_Sum := 0;[m
[31m-      begin[m
[31m-         for J in Index_PRF_Eta_2_Bytes range 0 .. Eta_2 - 1 loop[m
[31m-            pragma Loop_Invariant (R >= 0);[m
[31m-            pragma Loop_Invariant (R <= Natural (J));[m
[31m-            R := R + Natural (SB (2 * I * Eta_2 + J));[m
[31m-         end loop;[m
[31m-         return R;[m
[31m-      end Sum_X;[m
[31m-[m
[31m-      function Sum_Y (I : in Index_256) return Bit_Sum[m
[31m-        with No_Inline,[m
[31m-             Global => SB[m
[31m-      is[m
[31m-         R : Bit_Sum := 0;[m
[31m-      begin[m
[31m-         for J in Index_PRF_Eta_2_Bytes range 0 .. Eta_2 - 1 loop[m
[31m-            pragma Loop_Invariant (R >= 0);[m
[31m-            pragma Loop_Invariant (R <= Natural (J));[m
[31m-            R := R + Natural (SB (2 * I * Eta_2 + Eta_2 + J));[m
[31m-         end loop;[m
[31m-         return R;[m
[31m-      end Sum_Y;[m
[31m-   begin[m
[31m-      for I in Index_256 loop[m
[31m-         declare[m
[31m-            X : constant Bit_Sum := Sum_X (I);[m
[31m-            Y : constant Bit_Sum := Sum_Y (I);[m
[31m-         begin[m
[31m-            --  This "-" _is_ modulo Q[m
[31m-            F (I) := Zq.T (X) - Zq.T (Y); --  implicitly mod Q[m
[31m-         end;[m
[31m-      end loop;[m
[31m-      return F;[m
[31m-   end SamplePolyCBD_Eta_2;[m
[31m-[m
[31m-[m
[31m-   --  Algorithm 8[m
[31m-   function NTT (F : in Poly_Zq) return NTT_Poly_Zq[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      subtype K_T is Byte range 1 .. 128;[m
[31m-      F_Hat : NTT_Poly_Zq;[m
[31m-      K     : K_T;[m
[31m-      Len   : Len_T;[m
[31m-      Count : Count_T;[m
[31m-[m
[31m-      procedure NTT_Inner (Zeta  : in     Zq.T;[m
[31m-                           Start : in     Index_256)[m
[31m-        with No_Inline,[m
[31m-             Global => (In_Out => F_Hat,[m
[31m-                        Input  => Len),[m
[31m-             Pre    => Start <= 252 and[m
[31m-                       Start + 2 * Len <= 256[m
[31m-      is[m
[31m-         T : Zq.T;[m
[31m-      begin[m
[31m-         for J in Index_256 range Start .. Start + (Len - 1) loop[m
[31m-            T               := Zeta * F_Hat (J + Len);[m
[31m-            F_Hat (J + Len) := F_Hat (J) - T;[m
[31m-            F_Hat (J)       := F_Hat (J) + T;[m
[31m-         end loop;[m
[31m-      end NTT_Inner;[m
[31m-[m
[31m-   begin[m
[31m-      F_Hat := NTT_Poly_Zq (F); --  calls _memcpy()[m
[31m-      K     := 1;[m
[31m-[m
[31m-      for I in NTT_Len_Bit_Index loop[m
[31m-         --  When I = 0, Len = 128, Count = 1[m
[31m-         --       I = 1, Len =  64, Count = 2[m
[31m-         --       ...[m
[31m-         --       I = 6, Len =   2, Count = 64[m
[31m-         Len   := 2**(7 - I);[m
[31m-         Count := 2**I;[m
[31m-         for J in I32 range 0 .. Count - 1 loop[m
[31m-            pragma Loop_Invariant (Count * Len = 128);[m
[31m-            pragma Loop_Invariant (J * 2 * Len <= 252);[m
[31m-            pragma Loop_Invariant (I32 (K) = 2**I + J);[m
[31m-            pragma Assert (K < 128);[m
[31m-            NTT_Inner (Zeta  => Zeta_ExpC (K),[m
[31m-                       Start => J * 2 * Len);[m
[31m-            K := K + 1;[m
[31m-         end loop;[m
[31m-[m
[31m-         --  When the inner loop terminates, K has been[m
[31m-         --  incremented Count times, therefore...[m
[31m-         pragma Assert (I32 (K) = 2**I + Count);[m
[31m-         --  But we know that Count = 2**I, so...[m
[31m-         pragma Assert (I32 (K) = 2 * 2**I);[m
[31m-         pragma Assert (I32 (K) = 2**(I + 1));[m
[31m-         pragma Loop_Invariant (2**(I + 1) <= 128);[m
[31m-         pragma Loop_Invariant (I32 (K) = 2**(I + 1));[m
[31m-      end loop;[m
[31m-      pragma Assert (I32 (K) = 128);[m
[31m-      pragma Assert (K = 128);[m
[31m-      return F_Hat; --  calls _memcpy()[m
[31m-   end NTT;[m
[31m-[m
[31m-   --  Overloaded - applies NTT to all elements of V[m
[31m-   function NTT (V : in Poly_Zq_Vector) return NTT_Poly_Zq_Vector[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : NTT_Poly_Zq_Vector;[m
[31m-   begin[m
[31m-      for I in R'Range loop[m
[31m-         R (I) := NTT (V (I));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end NTT;[m
[31m-[m
[31m-   --  Algorithm 9[m
[31m-   function NTT_Inv (F : in NTT_Poly_Zq) return Poly_Zq[m
[31m-     with No_Inline [m
[31m-         --   Post => (NTT (NTT_Inv'Result) = F)[m
[31m-   is[m
[31m-      subtype K_T is Byte range 0 .. 127;[m
[31m-      F_Hat : Poly_Zq;[m
[31m-      K     : K_T;[m
[31m-      Len   : Len_T;[m
[31m-      Count : Count_T;[m
[31m-[m
[31m-      procedure NTT_Inv_Inner (Zeta  : in     Zq.T;[m
[31m-                               Start : in     Index_256)[m
[31m-        with No_Inline,[m
[31m-             Global => (In_Out => F_Hat,[m
[31m-                        Input => Len),[m
[31m-             Pre    => Start <= 252 and[m
[31m-                       Start + 2 * Len <= 256[m
[31m-      is[m
[31m-         T : Zq.T;[m
[31m-      begin[m
[31m-         for J in Index_256 range Start .. Start + (Len - 1) loop[m
[31m-            T := F_Hat (J);[m
[31m-            F_Hat (J) := T + F_Hat (J + Len);[m
[31m-            F_Hat (J + Len) := Zeta * (F_Hat (J + Len) - T);[m
[31m-         end loop;[m
[31m-      end NTT_Inv_Inner;[m
[31m-   begin[m
[31m-      F_Hat := Poly_Zq (F); --  calls _memcpy()[m
[31m-      K     := 127;[m
[31m-[m
[31m-      --  note "reverse" loop here for NTT_Inv[m
[31m-      for I in reverse NTT_Len_Bit_Index loop[m
[31m-         --  When I = 6, Len =   2, Count = 64[m
[31m-         --       I = 5, Len =   4, Count = 32[m
[31m-         --       ...[m
[31m-         --       I = 0, Len = 128, Count = 1[m
[31m-         Len   := 2**(7 - I);[m
[31m-         Count := 2**I;[m
[31m-         for J in I32 range 0 .. Count - 1 loop[m
[31m-            pragma Loop_Invariant (Count * Len = 128);[m
[31m-            pragma Loop_Invariant (J * 2 * Len <= 252);[m
[31m-            pragma Loop_Invariant (I32 (K) = 2**I + Count - J - 1);[m
[31m-[m
[31m-            NTT_Inv_Inner (Zeta  => Zeta_ExpC (K),[m
[31m-                           Start => J * 2 * Len);[m
[31m-            K := K - 1;[m
[31m-         end loop;[m
[31m-[m
[31m-         --  When the inner loop terminates, K has been[m
[31m-         --  decremented Count times, therefore[m
[31m-         --  K = 2**I + Count - Count - 1, which simplifies to[m
[31m-         pragma Loop_Invariant (I32 (K) = 2**I - 1);[m
[31m-      end loop;[m
[31m-[m
[31m-      --  Substitute I = 0 into the outer loop invariant to get[m
[31m-      pragma Assert (K = 0);[m
[31m-      return F_Hat * 3303;[m
[31m-   end NTT_Inv;[m
[31m-[m
[31m-   --  Overloaded - applies NTT to all elements of V[m
[31m-   function NTT_Inv (V : in NTT_Poly_Zq_Vector) return Poly_Zq_Vector[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : Poly_Zq_Vector;[m
[31m-   begin[m
[31m-      for I in R'Range loop[m
[31m-         R (I) := NTT_Inv (V (I));[m
[31m-      end loop;[m
[31m-      return R;[m
[31m-   end NTT_Inv;[m
[31m-[m
[31m-[m
[31m-   --  Algorithms 10 and 11[m
[31m-   --  BaseCaseMultiply is inlined here in MultiplyNTTs[m
[31m-   function MultiplyNTTs (F, G : in NTT_Poly_Zq) return NTT_Poly_Zq[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      H : NTT_Poly_Zq := (others => 0); --  calls _memset()[m
[31m-   begin[m
[31m-      for I in Index_128 loop[m
[31m-         declare[m
[31m-            A0    : constant Zq.T := F (2 * I);[m
[31m-            A1    : constant Zq.T := F (2 * I + 1);[m
[31m-            B0    : constant Zq.T := G (2 * I);[m
[31m-            B1    : constant Zq.T := G (2 * I + 1);[m
[31m-            Gamma : constant Zq.T := Gamma_Table (I);[m
[31m-            B1G   : constant Zq.T := B1 * Gamma;[m
[31m-         begin[m
[31m-            H (2 * I)     := (A0 * B0) + (A1 * B1G);[m
[31m-            H (2 * I + 1) := (A0 * B1) + (A1 * B0);[m
[31m-         end;[m
[31m-      end loop;[m
[31m-      return H;[m
[31m-   end MultiplyNTTs;[m
[31m-[m
[31m-   --  FIPS 203, line 530, equation 1 defines a "dot product" operator between[m
[31m-   --  matrices and vectors of Poly_Zq, so we declare it thus:[m
[31m-   function "*" (Left  : in NTT_Poly_Matrix;[m
[31m-                 Right : in NTT_Poly_Zq_Vector) return NTT_Poly_Zq_Vector[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : NTT_Poly_Zq_Vector := (others => Null_NTT_Poly_Zq); --  calls _memset()[m
[31m-   begin[m
[31m-      for I in K_Range loop[m
[31m-         for J in K_Range loop[m
[31m-            R (I) := R (I) + MultiplyNTTs (Left (I) (J), Right (J)); --  calls _memcpy()[m
[31m-         end loop;[m
[31m-      end loop;[m
[31m-      return R; --  calls _memcpy()[m
[31m-   end "*";[m
[31m-[m
[31m-   --  Dot product of K-length vectors of NTT_Poly_Zq. FIPS 203 line 530,[m
[31m-   --  third equation[m
[31m-   function "*" (Left  : in NTT_Poly_Zq_Vector;[m
[31m-                 Right : in NTT_Poly_Zq_Vector) return NTT_Poly_Zq[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      R : NTT_Poly_Zq := Null_NTT_Poly_Zq; --  calls _memset()[m
[31m-   begin[m
[31m-      for J in K_Range loop[m
[31m-         R := R + MultiplyNTTs (Left (J), Right (J)); --  calls _memcpy()[m
[31m-      end loop;[m
[31m-      return R; --  calls _memcpy()[m
[31m-   end "*";[m
[31m-[m
[31m-[m
[31m-[m
[31m-   -------------------------------------[m
[31m-   --  K-PKE KeyGen, Encrypt and Decrypt[m
[31m-   -------------------------------------[m
[31m-[m
[31m-   function Transpose (X : in NTT_Poly_Matrix) return NTT_Poly_Matrix[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      T : NTT_Poly_Matrix := (others => (others => Null_NTT_Poly_Zq)); --  calls _memset()[m
[31m-   begin[m
[31m-      for I in K_Range loop[m
[31m-         for J in K_Range loop[m
[31m-            T (J) (I) := X (I) (J); --  calls _memcpy()[m
[31m-         end loop;[m
[31m-      end loop;[m
[31m-      return T;[m
[31m-   end Transpose;[m
[31m-[m
[31m-   --  Generating the A_Hat matrix is common to K_PKE_KeyGen and[m
[31m-   --  K_PKE_Encrypt, so is factored out here[m
[31m-   procedure Generate_A_Hat_Matrix (Rho   : in     Bytes_32;[m
[31m-                                    A_Hat :    out NTT_Poly_Matrix)[m
[31m-     with Relaxed_Initialization => A_Hat,[m
[31m-          Post => A_Hat'Initialized[m
[31m-   is[m
[31m-   begin[m
[31m-      --  In order to avoid a double-initialization of A_Hat, we prove[m
[31m-      --  safe initialization of A_Hat by proof here, rather than using[m
[31m-      --  the PDG flow-analysis engine.  Therefore, A_Hat is marked[m
[31m-      --  with the "Relaxed_Initialization" aspect, and loop[m
[31m-      --  invariants are used to track initialization of each slice[m
[31m-      --  and element of A_Hat.[m
[31m-      for I in K_Range loop[m
[31m-         for J in K_Range loop[m
[31m-            A_Hat (I) (J) := XOF_Then_SampleNTT (Rho, Byte (J), Byte (I));[m
[31m-[m
[31m-            --  The first I-1 slices of R are fully initialized and[m
[31m-            --  the first J elements of slice I are initialized[m
[31m-            pragma Loop_Invariant (A_Hat (K_Range'First .. I - 1)'Initialized and[m
[31m-                                   A_Hat (I) (K_Range'First .. J)'Initialized);[m
[31m-[m
[31m-         end loop;[m
[31m-[m
[31m-         --  The first I slices of A_Hat are fully initialized[m
[31m-         pragma Loop_Invariant (A_Hat (K_Range'First .. I)'Initialized);[m
[31m-[m
[31m-      end loop;[m
[31m-[m
[31m-      --  All slices of R are now initialized...[m
[31m-      pragma Assert (A_Hat (K_Range'First .. K_Range'Last)'Initialized);[m
[31m-      --  ...and therefore[m
[31m-      pragma Assert (A_Hat'Initialized);[m
[31m-   end Generate_A_Hat_Matrix;[m
[31m-[m
[31m-   --  Generating a Poly_Zq_Vector with Eta_1 is common to K_PKE_KeyGen and[m
[31m-   --  K_PKE_Encrypt, so is factored out here[m
[31m-   procedure Generate_Poly_Zq_Vector_With_Eta_1[m
[31m-      (Sigma     : in     Bytes_32;[m
[31m-       Initial_N : in     Byte;[m
[31m-       V         :    out Poly_Zq_Vector)[m
[31m-     with Pre => Initial_N = 0 or Initial_N = K[m
[31m-   is[m
[31m-      N : Byte := Initial_N;[m
[31m-   begin[m
[31m-      for I in K_Range loop[m
[31m-         pragma Loop_Invariant (N = Initial_N + Byte (I));[m
[31m-         V (I) := SamplePolyCBD_Eta_1 (PRF_Eta_1 (Sigma, N));[m
[31m-         N := N + 1;[m
[31m-      end loop;[m
[31m-   end Generate_Poly_Zq_Vector_With_Eta_1;[m
[31m-[m
[31m-   --  Generating a Poly_Zq_Vector with Eta_2 is common to K_PKE_KeyGen and[m
[31m-   --  K_PKE_Encrypt, so is factored out here[m
[31m-   procedure Generate_Poly_Zq_Vector_With_Eta_2[m
[31m-      (Sigma     : in     Bytes_32;[m
[31m-       V         :    out Poly_Zq_Vector)[m
[31m-   is[m
[31m-      N : Byte := K;[m
[31m-   begin[m
[31m-      for I in K_Range loop[m
[31m-         pragma Loop_Invariant (N = K + Byte (I));[m
[31m-         V (I) := SamplePolyCBD_Eta_2 (PRF_Eta_2 (Sigma, N));[m
[31m-         N := N + 1;[m
[31m-      end loop;[m
[31m-   end Generate_Poly_Zq_Vector_With_Eta_2;[m
[31m-[m
[31m-   --  Algorithm 12, FIPS 203 5.1[m
[31m-   function K_PKE_KeyGen (Random_D : in Bytes_32) return PKE_Key[m
[31m-     is separate;[m
[31m-[m
[31m-   --  Algorithm 13, FIPS 203 5.2[m
[31m-   function K_PKE_Encrypt (EK_PKE   : in PKE_Encryption_Key;[m
[31m-                           M        : in Bytes_32;[m
[31m-                           Random_R : in Bytes_32) return Ciphertext[m
[31m-   is[m
[31m-      A_Hat : NTT_Poly_Matrix;[m
[31m-[m
[31m-      R, E1, U     : Poly_Zq_Vector;[m
[31m-      R_Hat, T_Hat : NTT_Poly_Zq_Vector;[m
[31m-[m
[31m-      E2, V, Mu : Poly_Zq;[m
[31m-      Rho       : Bytes_32;[m
[31m-      C1        : Poly_UDU_Bytes;[m
[31m-      C2        : Bytes_UDV;[m
[31m-   begin[m
[31m-      T_Hat := ByteDecode12 (EK_PKE (0 .. 384 * K - 1));[m
[31m-      Rho := EK_PKE (384 * K .. EK_PKE'Last); --  Should be exactly 32 bytes[m
[31m-[m
[31m-      Generate_A_Hat_Matrix (Rho, A_Hat);[m
[31m-      Generate_Poly_Zq_Vector_With_Eta_1 (Random_R, 0, R);[m
[31m-      Generate_Poly_Zq_Vector_With_Eta_2 (Random_R, E1);[m
[31m-[m
[31m-      E2 := SamplePolyCBD_Eta_2 (PRF_Eta_2 (Random_R, K * 2));[m
[31m-      R_Hat := NTT (R);[m
[31m-[m
[31m-      U := NTT_Inv (Transpose (A_Hat) * R_Hat) + E1;[m
[31m-[m
[31m-      Mu := Decompress1 (ByteDecode1 (M));[m
[31m-      V := NTT_Inv (T_Hat * R_Hat) + E2 + Mu;[m
[31m-[m
[31m-      C1 := ByteEncodeDU (CompressDU (U));[m
[31m-      C2 := ByteEncodeDV (CompressDV (V));[m
[31m-      return C1 & C2; --  calls _memcpy()[m
[31m-   end K_PKE_Encrypt;[m
[31m-[m
[31m-[m
[31m-   --  Algorithm 14, FIPS 203 5.2[m
[31m-   function K_PKE_Decrypt (DK_PKE   : in PKE_Decryption_Key;[m
[31m-                           C        : in Ciphertext) return Bytes_32[m
[31m-     with No_Inline[m
[31m-   is[m
[31m-      C1    : Poly_UDU_Bytes;[m
[31m-      C2    : Bytes_UDV;[m
[31m-      U     : Poly_Zq_Vector;[m
[31m-      S_Hat : NTT_Poly_Zq_Vector;[m
[31m-      V, W  : Poly_Zq;[m
[31m-      M     : Bytes_32;[m
[31m-   begin[m
[31m-      C1 := C (0 .. 32 * DU * K - 1); --  calls _memcpy()[m
[31m-      C2 := C (32 * DU * K .. 32 * (DU * K + DV) - 1);[m
[31m-[m
[31m-      U := DecompressDU (ByteDecodeDU (C1));[m
[31m-      V := DecompressDV (ByteDecodeDV (C2));[m
[31m-[m
[31m-      S_Hat := ByteDecode12 (DK_PKE);[m
[31m-[m
[31m-      W := V - NTT_Inv (S_Hat * NTT (U));[m
[31m-[m
[31m-      M := ByteEncode1 (Compress1 (W));[m
[31m-      return M;[m
[31m-   end K_PKE_Decrypt;[m
[31m-[m
[31m-   --  Constant time equality test for unconstrained Byte_Seq's, where[m
[31m-   --  bounds match exactly.[m
[31m-   function Byte_Seq_Equal (X, Y : in Byte_Seq) return Boolean[m
[31m-     with No_Inline,[m
[31m-          Global => null,[m
[31m-          Pre    => X'First = Y'First and[m
[31m-                    X'Last  = Y'Last and[m
[31m-                    X'Length >= 1 and[m
[31m-                    Y'Length >= 1 and[m
[31m-                    X'Length = Y'Length,[m
[31m-          Post   => Byte_Seq_Equal'Result =[m
[31m-                      (for all I in X'Range => X (I) = Y (I));[m
[31m-[m
[31m-   function Byte_Seq_Equal (X, Y : in Byte_Seq) return Boolean[m
[31m-   is[m
[31m-      D : Boolean := True;[m
[31m-      I : N32 := X'First;[m
[31m-   begin[m
[31m-      --  Explicit loop statement here to avoid dead branch that[m
[31m-      --  a "for" loop generates when X'Length = 0[m
[31m-      loop[m
[31m-         D := D and (X (I) = Y (I));[m
[31m-         pragma Loop_Invariant[m
[31m-           (I >= X'First and I <= X'Last and[m
[31m-            (D = (for all J in N32 range X'First .. I => X (J) = Y (J))));[m
[31m-         exit when I = X'Last;[m
[31m-         I := I + 1;[m
[31m-      end loop;[m
[31m-      return D;[m
[31m-   end Byte_Seq_Equal;[m
[31m-[m
[31m-[m
[31m-   --=======================================[m
[31m-   --  Exported subprogram bodies[m
[31m-   --=======================================[m
[31m-[m
[31m-   function MLKEM_KeyGen (Random_D : in Bytes_32;[m
[31m-                          Random_Z : in Bytes_32) return MLKEM_Key[m
[31m-   is[m
[31m-      PKE_K : PKE_Key;[m
[31m-      DK    : MLKEM_Decapsulation_Key;[m
[31m-      HEK   : Bytes_32;[m
[31m-   begin[m
[31m-      PKE_K := K_PKE_KeyGen (Random_D); --  calls _memcpy()[m
[31m-      HEK := H (PKE_K.EK);[m
[31m-      DK := Byte_Seq (PKE_K.DK) & --  calls _memcpy() several times[m
[31m-            Byte_Seq (PKE_K.EK) &[m
[31m-            HEK &[m
[31m-            Random_Z;[m
[31m-[m
[31m-      return MLKEM_Key'(EK => PKE_K.EK, --  calls _memcpy()[m
[31m-                        DK => DK);[m
[31m-   end MLKEM_KeyGen;[m
[31m-[m
[31m-[m
[31m-   function EK_Is_Valid_For_Encaps (EK : in MLKEM_Encapsulation_Key)[m
[31m-     return Boolean[m
[31m-   is[m
[31m-      Key_To_Check : constant Poly_Zq_Vector_Bytes := EK (0 .. 384 * K - 1); --  calls _memcpy()[m
[31m-      Decoded      : NTT_Poly_Zq_Vector;[m
[31m-      Reencoded    : Poly_Zq_Vector_Bytes;[m
[31m-   begin[m
[31m-      --  FIPS 203 6.2 line 980 - 997[m
[31m-      --    1. Check on the length of EK is a static type-check in SPARK, so[m
[31m-      --       nothing to do here.[m
[31m-      --    2. Modulus check - check that Decode/Encode is idempotent:[m
[31m-      Decoded := ByteDecode12 (Key_To_Check);[m
[31m-      Reencoded := ByteEncode12 (Decoded);[m
[31m-      return Byte_Seq_Equal (Key_To_Check, Reencoded);[m
[31m-   end EK_Is_Valid_For_Encaps;[m
[31m-[m
[31m-[m
[31m-   procedure MLKEM_Encaps (EK       : in     MLKEM_Encapsulation_Key;[m
[31m-                           Random_M : in     Bytes_32;[m
[31m-                           SS       :    out Bytes_32;[m
[31m-                           C        :    out Ciphertext)[m
[31m-   is[m
[31m-      KR : Bytes_64;[m
[31m-   begin[m
[31m-      KR := G (Random_M & H (EK));[m
[31m-      SS := KR (0 .. 31);[m
[31m-      C  := K_PKE_Encrypt (EK, Random_M, Bytes_32 (KR (32 .. 63))); --  calls _memcpy()[m
[31m-   end MLKEM_Encaps;[m
[31m-[m
[31m-   function MLKEM_Decaps (C  : in Ciphertext;[m
[31m-                          DK : in MLKEM_Decapsulation_Key) return Bytes_32[m
[31m-   is[m
[31m-      DK_PKE : PKE_Decryption_Key;[m
[31m-      EK_PKE : PKE_Encryption_Key;[m
[31m-      H      : Bytes_32;[m
[31m-      Z      : Bytes_32;[m
[31m-      M_Tick : Bytes_32;[m
[31m-      K_Bar  : Bytes_32;[m
[31m-      KR     : Bytes_64;[m
[31m-      C_Tick : Ciphertext;[m
[31m-[m
[31m-      Result : Bytes_32;[m
[31m-[m
[31m-      --  Constant time conditional swap of Result and K_Bar.[m
[31m-      --  For illustration, this procedure is proven correct[m
[31m-      --  with the following Contract_Cases postcondition.[m
[31m-      procedure CSwap (Swap : in Boolean)[m
[31m-        with Global => (In_Out => (Result, K_Bar)),[m
[31m-             No_Inline,[m
[31m-             Contract_Cases =>[m
[31m-               (Swap     => (K_Bar = Result'Old and Result = K_Bar'Old),[m
[31m-                not Swap => (K_Bar = K_Bar'Old  and Result = Result'Old));[m
[31m-[m
[31m-      procedure CSwap (Swap : in Boolean)[m
[31m-      is[m
[31m-         -- Conditional swap from Hacker's Delight 2-19[m
[31m-         T : Byte;[m
[31m-         C : constant Byte := 16#FF# * Boolean'Pos (Swap);[m
[31m-      begin[m
[31m-         for I in Index_32 loop[m
[31m-            T := C and (K_Bar (I) xor Result (I));[m
[31m-            K_Bar (I) := K_Bar (I) xor T;[m
[31m-            Result (I) := Result (I) xor T;[m
[31m-[m
[31m-            pragma Loop_Invariant[m
[31m-              (if Swap then[m
[31m-                 (for all J in Index_32 range 0 .. I =>[m
[31m-                      (K_Bar (J) = Result'Loop_Entry (J) and[m
[31m-                       Result (J) = K_Bar'Loop_Entry (J)))[m
[31m-               else[m
[31m-                 (for all J in Index_32 range 0 .. I =>[m
[31m-                      (K_Bar (J) = K_Bar'Loop_Entry (J) and[m
[31m-                       Result (J) = Result'Loop_Entry (J)))[m
[31m-              );[m
[31m-         end loop;[m
[31m-      end CSwap;[m
[31m-[m
[31m-   begin[m
[31m-      DK_PKE := PKE_Decryption_Key (DK (0 .. 384 * K - 1)); --  calls _memcpy()[m
[31m-      EK_PKE := PKE_Encryption_Key (DK (384 * K .. 768 * K + 32 - 1)); --  calls _memcpy()[m
[31m-      H      := Bytes_32 (DK (768 * K + 32 .. 768 * K + 64 - 1));[m
[31m-      Z      := Bytes_32 (DK (768 * K + 64 .. 768 * K + 96 - 1));[m
[31m-[m
[31m-      M_Tick := K_PKE_Decrypt (DK_PKE, C);[m
[31m-      KR     := G (M_Tick & H);[m
[31m-[m
[31m-      K_Bar  := J (Z & C); --  calls _memcpy()[m
[31m-[m
[31m-      C_Tick := K_PKE_Encrypt (EK_PKE, M_Tick, Bytes_32 (KR (32 .. 63)));[m
[31m-[m
[31m-      Result := KR (0 .. 31);[m
[31m-[m
[31m-      --  if C /= C_Tick then swap K_Bar into Result.[m
[31m-      --  This fulfills the FIPS-203 spec for implicit rejection[m
[31m-      --  but does so in constant time.[m
[31m-      CSwap (not Byte_Seq_Equal (C, C_Tick));[m
[31m-[m
[31m-      pragma Unreferenced (K_Bar);[m
[31m-      return Result;[m
[31m-   end MLKEM_Decaps;[m
[31m-[m
[31m-end MLKEM;[m
[31m-[m
[1mdiff --git a/spark_ada/src/recursntt.adb b/spark_ada/src/recursntt.adb[m
[1mindex d45390d..7bdf6b9 100644[m
[1m--- a/spark_ada/src/recursntt.adb[m
[1m+++ b/spark_ada/src/recursntt.adb[m
[36m@@ -17,33 +17,186 @@[m [mis[m
             Res (0) := E (0);[m
         else[m
             declare[m
[31m-                E_Even : Array_Zq (0 .. Index_Ref (E'Length / 2) - 1) := Generic_Sum.Extract_Even (E);[m
[31m-                E_Odd : Array_Zq (0 .. Index_Ref (E'Length / 2) - 1) := Generic_Sum.Extract_Odd (E);[m
[31m-                Psi_Square : T_Ref := Square (E, Psi);[m
[31m-                A_Recurs : Array_Zq (E_Even'Range) := NTT_Recurs (E_Even, Psi_Square);[m
[31m-                B_Recurs : Array_Zq (E_Odd'Range) := NTT_Recurs (E_Odd, Psi_Square);[m
[32m+[m[32m                Is_Pow_Of_Two_Def : constant Boolean := Lemma_Is_Pow_Of_Two_Def (E'Length);[m
[32m+[m[32m                E_Even : Array_Zq renames Generic_Sum.Extract_Even (E);[m
[32m+[m[32m                E_Odd : Array_Zq renames Generic_Sum.Extract_Odd (E);[m
[32m+[m[32m                Psi_Square : T_Ref renames Square (E, Psi);[m
[32m+[m[32m                A_Recurs : Array_Zq renames NTT_Recurs (E_Even, Psi_Square);[m
[32m+[m[32m                B_Recurs : Array_Zq renames NTT_Recurs (E_Odd, Psi_Square);[m
             begin[m
                 for J_Dex in 0 .. Index_Ref (E'Length / 2) - 1 loop[m
[31m-                        Res (J_Dex) := A_Recurs (J_Dex) + Psi ** (2 * To_Big (J_Dex)) * B_Recurs (J_Dex);[m
[31m-                        Res (J_Dex + Index_Ref (E'Length / 2)) := A_Recurs (J_Dex) - Psi ** (2 * To_Big (J_Dex)) * B_Recurs (J_Dex);[m
[32m+[m[32m                        Res (J_Dex) := A_Recurs (J_Dex) + Psi ** (2 * To_Big (J_Dex) + 1) * B_Recurs (J_Dex);[m
[32m+[m[32m                        Res (J_Dex + Index_Ref (E'Length / 2)) := A_Recurs (J_Dex) + (- Psi ** (2 * To_Big (J_Dex) + 1)) * B_Recurs (J_Dex);[m
[32m+[m[32m                        declare[m
[32m+[m[32m                          Small_Val : constant T_Ref := Val_Small (E, Psi, J_Dex) with Ghost;[m
[32m+[m[32m                          Big_Val   : constant T_Ref := Val_Big (E, Psi, J_Dex + Index_Ref (E'Length / 2)) with Ghost;[m
[32m+[m[32m                        begin[m
[32m+[m[32m                          pragma Assert (Res (J_Dex)'Initialized and then[m
[32m+[m[32m                                Res (J_Dex) = Small_Val);[m
[32m+[m[32m                          pragma Assert (Res (J_Dex + Index_Ref (E'Length / 2))'Initialized and then[m
[32m+[m[32m                                Res (J_Dex + Index_Ref (E'Length / 2)) = Big_Val);[m
[32m+[m[32m                        end;[m
 [m
                         pragma Loop_Invariant ([m
                             (for all J in 0 .. J_Dex => ([m
[31m-                                Res (J) = [m
[31m-                                    NTT_Recurs (Generic_Sum.Extract_Even (E), Square (E, Psi)) (J) + [m
[31m-                                    Psi ** (2 * To_Big (J)) * NTT_Recurs (Generic_Sum.Extract_Odd (E), Square (E, Psi)) (J) and[m
[31m-                                Res (J + Index_Ref (E'Length / 2)) =[m
[31m-                                    NTT_Recurs (Generic_Sum.Extract_Even (E), Square (E, Psi)) (J) - [m
[31m-                                    Psi ** (2 * To_Big (J)) * NTT_Recurs (Generic_Sum.Extract_Odd (E), Square (E, Psi)) (J)[m
[32m+[m[32m                                Res (J)'Initialized and then[m
[32m+[m[32m                                Res (J) = Val_Small (E, Psi, J)[m
[32m+[m[32m                            ))[m[41m [m
[32m+[m[32m                        );[m
[32m+[m[32m                        pragma Loop_Invariant ([m
[32m+[m[32m                            (for all J in Index_Ref (E'Length / 2) .. J_Dex + Index_Ref (E'Length / 2) => ([m
[32m+[m[32m                                Res (J)'Initialized and then[m
[32m+[m[32m                                Res (J) = Val_Big (E, Psi, J)[m
                             )) [m
                         );[m
                 end loop;[m
[31m-                pragma Assume (Res'Initialized);[m
             end;[m
         end if;[m
         return Res;[m
     end NTT_Recurs;[m
 [m
[32m+[m[32m   procedure Lift1 (E_Even, E : Array_Zq; Psi : T_Ref; J_Dex : Index_Ref) with[m
[32m+[m[32m     Pre => (E'Length > 1 and then Is_Pow_Of_Two (E'Length / 2)) and then[m
[32m+[m[32m     (Psi ** To_Big_Integer (E'Length) = - 1 and[m
[32m+[m[32m        (E'First = 0 and E'Last >= E'First and E'Length <= Integer (Index_Ref'Last + 1))) and then[m[41m  [m
[32m+[m[32m     (Is_Pow_Of_Two (E'Length)) and then J_Dex in 0 .. Index_Ref (E'Length / 2) - 1[m
[32m+[m[32m     and then (E_Even'First = 0 and then E_Even'Last = Index_Ref (E'Length / 2) - 1)[m
[32m+[m[32m     and then (for all I_Dex in E_Even'Range =>[m
[32m+[m[32m                 (Array_Generator_Very_Inner (E_Even, Square (E, Psi), J_Dex) (I_Dex) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I_Dex))),[m
[32m+[m[32m     Post => NTT_Ref (E_Even, Square (E, Psi)) (J_Dex) = Generic_Sum.Sum (Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex)));[m
[32m+[m
[32m+[m[32m   procedure Lift1 (E_Even, E : Array_Zq; Psi : T_Ref; J_Dex : Index_Ref) is -- For the even terms[m
[32m+[m[32m      Psi_Square : T_Ref renames Square (E, Psi);[m
[32m+[m[32m   begin[m
[32m+[m[32m      begin[m
[32m+[m[32m         pragma Assert (for all I_Dex in E_Even'Range =>[m[41m [m
[32m+[m[32m                          Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) (I_Dex) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I_Dex));[m
[32m+[m[32m         pragma Assert_And_Cut (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex)));[m
[32m+[m[32m      end;[m
[32m+[m[32m      pragma Assert (By ([m
[32m+[m[32m                     Generic_Sum.Sum (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex)) = Generic_Sum.Sum (Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex))),[m
[32m+[m[32m                     Generic_Sum.Lemma_Sum_Extensional (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) , Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex)))[m
[32m+[m[32m                    ));[m
[32m+[m[32m      pragma Assert (NTT_Ref (E_Even, Psi_Square) (J_Dex) = NTT_Inner_Ref (E_Even, Psi_Square, 0, J_Dex));[m
[32m+[m[32m      pragma Assert (NTT_Ref (E_Even, Psi_Square) (J_Dex) = Generic_Sum.Sum (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex)));[m
[32m+[m[32m   end Lift1;[m
[32m+[m
[32m+[m[32m   procedure Lift2 (E_Odd, E : Array_Zq; Psi : T_Ref; J_Dex : Index_Ref) with[m
[32m+[m[32m     Pre => (E'Length > 1 and then Is_Pow_Of_Two (E'Length / 2)) and then[m
[32m+[m[32m     (Psi ** To_Big_Integer (E'Length) = - 1 and[m
[32m+[m[32m        (E'First = 0 and E'Last >= E'First and E'Length <= Integer (Index_Ref'Last + 1))) and then[m[41m  [m
[32m+[m[32m     (Is_Pow_Of_Two (E'Length)) and then J_Dex in 0 .. Index_Ref (E'Length / 2) - 1[m
[32m+[m[32m     and then (E_Odd'First = 0 and then E_Odd'Last = Index_Ref (E'Length / 2) - 1)[m
[32m+[m[32m     and then (for all I_Dex in E_Odd'Range =>[m
[32m+[m[32m                 (Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Square (E, Psi), J_Dex) (I_Dex) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I_Dex)),[m
[32m+[m[32m     Post => (Psi ** (2 * To_Big (J_Dex) + 1)) * NTT_Ref (E_Odd, Square (E, Psi)) (J_Dex) = Generic_Sum.Sum (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex)));[m
[32m+[m
[32m+[m[32m   procedure Lift2 (E_Odd, E : Array_Zq; Psi : T_Ref; J_Dex : Index_Ref) is -- For the even terms[m
[32m+[m[32m      Psi_Square : T_Ref renames Square (E, Psi);[m
[32m+[m[32m   begin[m
[32m+[m[32m      begin -- One one side Sum of Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) equals ...[m[41m [m
[32m+[m[32m         begin[m
[32m+[m[32m            pragma Assert (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)'First = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex))'First);[m
[32m+[m[32m            pragma Assert (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)'Length = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex))'Length);[m
[32m+[m[32m            pragma Assert (for all I_Dex in E_Odd'Range => ([m
[32m+[m[32m                                                            (Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I_Dex) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I_Dex)[m
[32m+[m[32m                                                           ));[m
[32m+[m[32m            pragma Assert_And_Cut (for all I_Dex in E_Odd'Range => (Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I_Dex) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I_Dex));[m
[32m+[m[32m         end;[m
[32m+[m[32m         pragma Assert (By ([m
[32m+[m[32m                        Generic_Sum.Sum (Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = Generic_Sum.Sum (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex))),[m
[32m+[m[32m                        Generic_Sum.Lemma_Sum_Extensional (Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)), Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex)))[m
[32m+[m[32m                       ));[m
[32m+[m[32m         pragma Assert_And_Cut (Generic_Sum.Sum (Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = Generic_Sum.Sum (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex))));[m
[32m+[m[32m      end;[m
[32m+[m[32m      begin -- One the other side Sum of Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) equals ... ,[m[41m [m
[32m+[m[32m         pragma Assert (NTT_Ref (E_Odd, Psi_Square) (J_Dex) = NTT_Inner_Ref (E_Odd, Psi_Square, 0, J_Dex));[m
[32m+[m[32m         begin[m
[32m+[m[32m            pragma Assert (for all I_Dex in E_Odd'Range => (Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) (I_Dex) = (Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I_Dex)));[m
[32m+[m[32m            pragma Assert (By ([m
[32m+[m[32m                                   Generic_Sum.Sum (Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = (Psi ** (2 * To_Big (J_Dex) + 1)) * Generic_Sum.Sum (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)),[m
[32m+[m[32m                                   Generic_Sum.Lemma_Sum_Linear_Scal_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex), Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)))[m
[32m+[m[32m                                  ));[m
[32m+[m[32m           pragma Assert_And_Cut (Generic_Sum.Sum (Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = (Psi ** (2 * To_Big (J_Dex) + 1)) * Generic_Sum.Sum (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))[m
[32m+[m[32m                                   );[m
[32m+[m[32m         end;[m
[32m+[m[32m         pragma Assert (Generic_Sum.Sum (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) = NTT_Ref (E_Odd, Psi_Square) (J_Dex));[m
[32m+[m[32m         pragma Assert (Generic_Sum.Sum (Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = (Psi ** (2 * To_Big (J_Dex) + 1)) * NTT_Ref (E_Odd, Psi_Square) (J_Dex));[m
[32m+[m[32m      end;[m
[32m+[m[32m   end Lift2;[m
[32m+[m
[32m+[m[32m   procedure Lift3 (E_Even, E : Array_Zq; Psi : T_Ref; J_Dex : Index_Ref) with[m
[32m+[m[32m     Pre => (E'Length > 1 and then Is_Pow_Of_Two (E'Length / 2)) and then[m
[32m+[m[32m     (Psi ** To_Big_Integer (E'Length) = - 1 and[m
[32m+[m[32m        (E'First = 0 and E'Last >= E'First and E'Length <= Integer (Index_Ref'Last + 1))) and then[m[41m  [m
[32m+[m[32m     (Is_Pow_Of_Two (E'Length)) and then J_Dex in 0 .. Index_Ref (E'Length / 2) - 1[m
[32m+[m[32m     and then (E_Even'First = 0 and then E_Even'Last = Index_Ref (E'Length / 2) - 1)[m
[32m+[m[32m     and then (for all I_Dex in E_Even'Range =>[m
[32m+[m[32m                 (Array_Generator_Very_Inner (E_Even, Square (E, Psi), J_Dex) (I_Dex) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Index_Ref (E'Length / 2))) (I_Dex))),[m
[32m+[m[32m     Post => NTT_Ref (E_Even, Square (E, Psi)) (J_Dex) = Generic_Sum.Sum (Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Index_Ref (E'Length / 2))));[m
[32m+[m
[32m+[m[32m   procedure Lift3 (E_Even, E : Array_Zq; Psi : T_Ref; J_Dex : Index_Ref) is -- For the even terms[m
[32m+[m[32m      Psi_Square : T_Ref renames Square (E, Psi);[m
[32m+[m[32m      Mid_Dex    : Index_Ref := Index_Ref (E'Length / 2);[m[41m [m
[32m+[m[32m   begin[m
[32m+[m[32m      begin[m
[32m+[m[32m         pragma Assert (for all I_Dex in E_Even'Range =>[m[41m [m
[32m+[m[32m                          Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) (I_Dex) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I_Dex));[m
[32m+[m[32m         pragma Assert_And_Cut (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)));[m
[32m+[m[32m      end;[m
[32m+[m[32m      pragma Assert (By ([m
[32m+[m[32m                     Generic_Sum.Sum (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex)) = Generic_Sum.Sum (Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex))),[m
[32m+[m[32m                     Generic_Sum.Lemma_Sum_Extensional (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) , Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)))[m
[32m+[m[32m                    ));[m
[32m+[m[32m      pragma Assert (NTT_Ref (E_Even, Psi_Square) (J_Dex) = NTT_Inner_Ref (E_Even, Psi_Square, 0, J_Dex));[m
[32m+[m[32m      pragma Assert (NTT_Ref (E_Even, Psi_Square) (J_Dex) = Generic_Sum.Sum (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex)));[m
[32m+[m[32m   end Lift3;[m
[32m+[m
[32m+[m[32m   procedure Lift4 (E_Odd, E : Array_Zq; Psi : T_Ref; J_Dex : Index_Ref) with[m
[32m+[m[32m     Pre => (E'Length > 1 and then Is_Pow_Of_Two (E'Length / 2)) and then[m
[32m+[m[32m     (Psi ** To_Big_Integer (E'Length) = - 1 and[m
[32m+[m[32m        (E'First = 0 and E'Last >= E'First and E'Length <= Integer (Index_Ref'Last + 1))) and then[m[41m  [m
[32m+[m[32m     (Is_Pow_Of_Two (E'Length)) and then J_Dex in 0 .. Index_Ref (E'Length / 2) - 1[m
[32m+[m[32m     and then (E_Odd'First = 0 and then E_Odd'Last = Index_Ref (E'Length / 2) - 1)[m
[32m+[m[32m     and then (for all I_Dex in E_Odd'Range =>[m
[32m+[m[32m                 (- Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Square (E, Psi), J_Dex) (I_Dex) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Index_Ref (E'Length / 2))) (I_Dex)),[m
[32m+[m[32m     Post => (- Psi ** (2 * To_Big (J_Dex) + 1)) * NTT_Ref (E_Odd, Square (E, Psi)) (J_Dex) = Generic_Sum.Sum (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Index_Ref (E'Length / 2))));[m
[32m+[m
[32m+[m[32m   procedure Lift4 (E_Odd, E : Array_Zq; Psi : T_Ref; J_Dex : Index_Ref) is -- For the even terms[m
[32m+[m[32m      Psi_Square : T_Ref renames Square (E, Psi);[m
[32m+[m[32m      Mid_Dex    : Index_Ref := Index_Ref (E'Length / 2);[m[41m [m
[32m+[m[32m   begin[m
[32m+[m[32m      begin -- One one side Sum of Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) equals ...[m[41m [m
[32m+[m[32m         begin[m
[32m+[m[32m            pragma Assert (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)'First = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex))'First);[m
[32m+[m[32m            pragma Assert (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)'Length = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex))'Length);[m
[32m+[m[32m            pragma Assert (for all I_Dex in E_Odd'Range => ([m
[32m+[m[32m                                                            (- Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I_Dex) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I_Dex)[m
[32m+[m[32m                                                           ));[m
[32m+[m[32m            pragma Assert_And_Cut (for all I_Dex in E_Odd'Range => (- Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I_Dex) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I_Dex));[m
[32m+[m[32m         end;[m
[32m+[m[32m         pragma Assert (By ([m
[32m+[m[32m                        Generic_Sum.Sum (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = Generic_Sum.Sum (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex))),[m
[32m+[m[32m                        Generic_Sum.Lemma_Sum_Extensional (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)), Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)))[m
[32m+[m[32m                       ));[m
[32m+[m[32m         pragma Assert_And_Cut (Generic_Sum.Sum (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = Generic_Sum.Sum (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex))));[m
[32m+[m[32m      end;[m
[32m+[m[32m      begin -- One the other side Sum of Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) equals ... ,[m[41m [m
[32m+[m[32m         pragma Assert (NTT_Ref (E_Odd, Psi_Square) (J_Dex) = NTT_Inner_Ref (E_Odd, Psi_Square, 0, J_Dex));[m
[32m+[m[32m         begin[m
[32m+[m[32m            pragma Assert (for all I_Dex in E_Odd'Range => (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) (I_Dex) = (- Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I_Dex)));[m
[32m+[m[32m            pragma Assert (By ([m
[32m+[m[32m                                   Generic_Sum.Sum (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = (- Psi ** (2 * To_Big (J_Dex) + 1)) * Generic_Sum.Sum (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)),[m
[32m+[m[32m                                   Generic_Sum.Lemma_Sum_Linear_Scal_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex), Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)))[m
[32m+[m[32m                                  ));[m
[32m+[m[32m           pragma Assert_And_Cut (Generic_Sum.Sum (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = (- Psi ** (2 * To_Big (J_Dex) + 1)) * Generic_Sum.Sum (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))[m
[32m+[m[32m                                   );[m
[32m+[m[32m         end;[m
[32m+[m[32m         pragma Assert (Generic_Sum.Sum (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) = NTT_Ref (E_Odd, Psi_Square) (J_Dex));[m
[32m+[m[32m         pragma Assert (Generic_Sum.Sum (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = (- Psi ** (2 * To_Big (J_Dex) + 1)) * NTT_Ref (E_Odd, Psi_Square) (J_Dex));[m
[32m+[m[32m      end;[m
[32m+[m[32m   end Lift4;[m
[32m+[m
     function Lemma_Recurs_Equiv_Ref (E : Array_Zq ; Psi : T_Ref) return Boolean[m
     is[m
     begin[m
[36m@@ -56,15 +209,18 @@[m [mis[m
             pragma Assert (NTT_Ref (E, Psi) = NTT_Recurs (E, Psi));[m
         else[m
             declare[m
[31m-                E_Even : Array_Zq (0 .. E'Length / 2 - 1) := Generic_Sum.Extract_Even (E);[m
[31m-                E_Odd : Array_Zq (0 .. E'Length / 2 - 1) := Generic_Sum.Extract_Odd (E);[m
[31m-                Psi_Square : T_Ref := Square (E, Psi);[m
[32m+[m[32m                Is_Pow_Of_Two_Def : constant Boolean := Lemma_Is_Pow_Of_Two_Def (E'Length);[m
[32m+[m[32m                E_Even : Array_Zq renames Generic_Sum.Extract_Even (E);[m
[32m+[m[32m                E_Odd : Array_Zq renames Generic_Sum.Extract_Odd (E);[m
[32m+[m[32m                Psi_Square : T_Ref renames Square (E, Psi);[m
                 Induction_Hypothesis_Even : Boolean := Lemma_Recurs_Equiv_Ref (E_Even, Psi_Square);[m
                 Induction_Hypothesis_Odd : Boolean := Lemma_Recurs_Equiv_Ref (E_Odd, Psi_Square);[m
 [m
                 Mid_Dex : Index_Ref := Index_Ref (E'Length / 2); [m
             begin[m
[32m+[m[32m                begin[m
                 for J_Dex in 0 .. Mid_Dex - 1 loop[m
[32m+[m[32m                    begin[m
                     for I_Dex in 0 .. Mid_Dex - 1 loop[m
                         begin[m
                             rewrite1 (E, E_Even, Psi, Psi_Square, J_Dex, I_Dex, To_Big (J_Dex), To_Big (I_Dex));[m
[36m@@ -73,9 +229,70 @@[m [mis[m
                         end;[m
                         begin[m
                             rewrite2 (E, E_Odd, Psi, Psi_Square, J_Dex, I_dex, To_Big (J_Dex), To_Big (I_Dex));[m
[31m-                            pragma Assert (Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) (I_Dex) = Array_Generator_Very_Inner (E, Psi, J_Dex) (2 * I_Dex + 1));[m
[31m-                            pragma Assert_And_Cut (Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) (I_Dex) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I_Dex));[m
[32m+[m[32m                            pragma Assert (Psi ** (2 * To_Big (J_Dex) + 1) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I_Dex) = Array_Generator_Very_Inner (E, Psi, J_Dex) (2 * I_Dex + 1));[m
[32m+[m[32m                            pragma Assert_And_Cut (Psi ** (2 * To_Big (J_Dex) + 1) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I_Dex) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I_Dex));[m
[32m+[m[32m                        end;[m
[32m+[m
[32m+[m[32m                        pragma Loop_Invariant (for all I in 0 .. I_Dex => ([m
[32m+[m[32m                            Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) (I) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I) and[m
[32m+[m[32m                            Psi ** (2 * To_Big (J_Dex) + 1) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I)[m
[32m+[m[32m                        ));[m
[32m+[m[32m                    end loop;[m
[32m+[m
[32m+[m[32m                        pragma Assert_And_Cut (for all I in 0 .. Mid_Dex - 1 => ([m
[32m+[m[32m                            Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) (I) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I) and[m
[32m+[m[32m                            Psi ** (2 * To_Big (J_Dex) + 1) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I)[m
[32m+[m[32m                        ));[m
[32m+[m[32m                    end;[m
[32m+[m
[32m+[m[32m                    begin -- For J_Dex[m
[32m+[m[32m                        begin[m
[32m+[m[32m                            pragma Assert (By (NTT_Recurs (E, Psi) (J_Dex) = NTT_Recurs (Generic_Sum.Extract_Even (E), Square (E, Psi)) (J_Dex) +[m[41m [m
[32m+[m[32m                                             Psi ** (2 * To_Big (J_Dex) + 1) * NTT_Recurs (Generic_Sum.Extract_Odd (E), Square (E, Psi)) (J_Dex),[m
[32m+[m[32m                                           NTT_Recurs (E, Psi) (J_Dex) = Val_Small (E, Psi, J_Dex)));[m
[32m+[m
[32m+[m
[32m+[m[32m                            begin -- For the even terms[m
[32m+[m[32m                                Lift1 (E_Even, E, Psi, J_Dex);[m
[32m+[m[32m                                pragma Assert (NTT_Recurs (E_Even, Psi_Square) (J_Dex) = NTT_Ref (E_Even, Psi_Square) (J_Dex));[m
[32m+[m[32m                                pragma Assert_And_Cut (NTT_Recurs (E_Even, Psi_Square) (J_Dex) = Generic_Sum.Sum (Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex))));[m
[32m+[m[32m                            end;[m
[32m+[m[32m                            begin -- For the odd terms[m
[32m+[m[32m                                Lift2 (E_Odd, E, Psi, J_Dex);[m
[32m+[m[32m                                pragma Assert (NTT_Recurs (E_Odd, Psi_Square) (J_Dex) = NTT_Ref (E_Odd, Psi_Square) (J_Dex));[m
[32m+[m[32m                                -- So ...[m
[32m+[m[32m                                pragma Assert_And_Cut ((Psi ** (2 * To_Big (J_Dex) + 1)) * NTT_Recurs (E_Odd, Psi_Square) (J_Dex) = Generic_Sum.Sum (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex))));[m
[32m+[m[32m                            end;[m
[32m+[m[32m                            pragma Assert_And_Cut ([m
[32m+[m[32m                                NTT_Recurs (E, Psi) (J_Dex) =[m[41m [m
[32m+[m[32m                                    Generic_Sum.Sum (Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex))) +[m[41m [m
[32m+[m[32m                                    Generic_Sum.Sum (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex)))[m
[32m+[m[32m                            );[m
                         end;[m
[32m+[m[32m                        pragma Assert (By ([m
[32m+[m[32m                            Generic_Sum.Sum (Array_Generator_Very_Inner (E, Psi, J_Dex)) =[m[41m [m
[32m+[m[32m                                    Generic_Sum.Sum (Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex))) +[m
[32m+[m[32m                                    Generic_Sum.Sum (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex)))[m
[32m+[m[32m                            ,[m
[32m+[m[32m                            Generic_Sum.Lemma_Split_Odd_Even (Array_Generator_Very_Inner (E, Psi, J_Dex))[m
[32m+[m[32m                        ));[m
[32m+[m[32m                        pragma Assert[m
[32m+[m[32m                         (By (NTT_Ref (E, Psi) (J_Dex) = Generic_Sum.Sum (Array_Generator_Very_Inner (E, Psi, J_Dex)),[m
[32m+[m[32m                              NTT_Ref (E, Psi) (J_Dex) = NTT_Inner_Ref (E, Psi, 0, J_Dex)));[m
[32m+[m[32m                        pragma Assert_And_Cut (NTT_Ref (E, Psi) (J_Dex) = NTT_Recurs (E, Psi) (J_Dex));[m
[32m+[m[32m                    end;[m
[32m+[m[32m                    pragma Loop_Invariant (for all I_Dex in 0 .. J_Dex => ([m
[32m+[m[32m                        NTT_Recurs (E, Psi) (I_Dex) = NTT_Ref (E, Psi) (I_Dex)[m
[32m+[m[32m                    ));[m
[32m+[m[32m                end loop;[m
[32m+[m[32m                    pragma Assert_And_Cut (for all J_Dex in 0 .. Mid_Dex - 1 => ([m
[32m+[m[32m                        NTT_Recurs (E, Psi) (J_Dex) = NTT_Ref (E, Psi) (J_Dex)[m
[32m+[m[32m                    ));[m
[32m+[m[32m            end;[m
[32m+[m[32m                begin[m
[32m+[m[32m                for J_Dex in 0 .. Mid_Dex - 1 loop[m
[32m+[m[32m                    begin[m
[32m+[m[32m                    for I_Dex in 0 .. Mid_Dex - 1 loop[m
                         begin[m
                             rewrite3 (E, E_Even, Psi, Psi_Square, Mid_Dex, J_Dex, I_Dex, To_Big (Mid_Dex), To_Big (J_Dex), To_Big (I_Dex));[m
                             pragma Assert (NTT_Very_Inner_Ref (E_Even, Psi_Square, J_Dex, I_Dex) = Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex) (2 * I_Dex));[m
[36m@@ -84,74 +301,42 @@[m [mis[m
                         begin[m
                             rewrite4 (E, E_Odd, Psi, Psi_Square, Mid_Dex, J_Dex, I_Dex, To_Big (Mid_Dex), To_Big (J_Dex), To_Big (I_Dex));[m
                             pragma Assert ((- Psi ** (2 * To_Big (J_Dex) + 1)) * NTT_Very_Inner_Ref (E_Odd, Psi_Square, J_Dex, I_Dex) = NTT_Very_Inner_Ref (E, Psi, J_Dex + Mid_Dex, 2 * I_Dex + 1));[m
[31m-                            pragma Assert (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) (I_Dex) = Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex) (2 * I_Dex + 1));[m
[32m+[m[32m                            pragma Assert (By ((- Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I_Dex) = Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex) (2 * I_Dex + 1),[m
[32m+[m[32m                                           Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I_Dex) = NTT_Very_Inner_Ref (E_Odd, Psi_Square, J_Dex, I_Dex)[m
[32m+[m[32m                                           and Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex) (2 * I_Dex + 1) = NTT_Very_Inner_Ref (E, Psi, J_Dex + Mid_Dex, 2 * I_Dex + 1)));[m
                             pragma Assert (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I_Dex) = Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex) (2 * I_Dex + 1));[m
[31m-                            pragma Assert_And_Cut (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) (I_Dex) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I_Dex));[m
[32m+[m[32m                            pragma Assert_And_Cut ((- Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I_Dex) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I_Dex));[m
                         end;[m
 [m
                         pragma Loop_Invariant (for all I in 0 .. I_Dex => ([m
[31m-                            Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) (I) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I) and[m
[31m-                            Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) (I) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex)) (I) and[m
                             Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) (I) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I) and[m
[31m-                            Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) (I) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I)[m
[32m+[m[32m                            (- Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I)[m
                         ));[m
                     end loop;[m
 [m
[32m+[m[32m                        pragma Assert_And_Cut (for all I in 0 .. Mid_Dex - 1 => ([m
[32m+[m[32m                            Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) (I) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I) and[m
[32m+[m[32m                            (- Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I)[m
[32m+[m[32m                        ));[m
[32m+[m[32m                    end;[m
[32m+[m
 [m
                     -- For J_Dex, just copy paste what is for J_Dex + Mid_Dex, and replace all occurences of J_Dex + Mid_Dex by J_Dex, - Psi by Psi, Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) by Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)).[m
 [m
                     begin -- For J_Dex + Mid_Dex[m
                         begin[m
[31m-                            pragma Assert (NTT_Recurs (E, Psi) (J_Dex + Mid_Dex) = NTT_Recurs (E_Even, Psi_Square) (J_Dex) + (- Psi ** (2 * To_Big (J_Dex) + 1)) * NTT_Recurs (E_Odd, Psi_Square) (J_Dex));[m
[32m+[m[32m                            pragma Assert (By (NTT_Recurs (E, Psi) (J_Dex + Mid_Dex) = NTT_Recurs (E_Even, Psi_Square) (J_Dex) + (- Psi ** (2 * To_Big (J_Dex) + 1)) * NTT_Recurs (E_Odd, Psi_Square) (J_Dex),[m
[32m+[m[32m                                           NTT_Recurs (E, Psi) (J_Dex + Mid_Dex) = Val_Big (E, Psi, J_Dex + Mid_Dex)));[m
[32m+[m
[32m+[m
                             begin -- For the even terms[m
[31m-                                begin[m
[31m-                                    pragma Assert (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex)'First = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex))'First);[m
[31m-                                    pragma Assert (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex)'Length = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex))'Length);[m
[31m-                                    pragma Assert (for all I_Dex in Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex)'Range => ([m
[31m-                                        Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) (I_Dex) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I_Dex)[m
[31m-                                    ));[m
[31m-                                    pragma Assert_And_Cut (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) = Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)));[m
[31m-                                end;[m
[31m-                                pragma Assert (By ([m
[31m-                                    Generic_Sum.Sum (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex)) = Generic_Sum.Sum (Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex))),[m
[31m-                                    Generic_Sum.Lemma_Sum_Extensional (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex) , Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)))[m
[31m-                                ));[m
[31m-                                pragma Assert (NTT_Ref (E_Even, Psi_Square) (J_Dex) = Generic_Sum.Sum (Array_Generator_Very_Inner (E_Even, Psi_Square, J_Dex)));[m
[31m-                                pragma Assert (By ([m
[31m-                                    NTT_Recurs (E_Even, Psi_Square) (J_Dex) = NTT_Ref (E_Even, Psi_Square) (J_Dex),[m
[31m-                                    Lemma_Recurs_Equiv_Ref (E_Even, Psi_Square)[m
[31m-                                ));[m
[32m+[m[32m                                pragma Assert (NTT_Recurs (E_Even, Psi_Square) (J_Dex) = NTT_Ref (E_Even, Psi_Square) (J_Dex));[m
[32m+[m[32m                                Lift3 (E_Even, E, Psi, J_Dex);[m
                                 pragma Assert_And_Cut (NTT_Recurs (E_Even, Psi_Square) (J_Dex) = Generic_Sum.Sum (Generic_Sum.Extract_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex))));[m
                             end;[m
                             begin -- For the odd terms[m
[31m-                                begin -- One one side Sum of Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) equals ... [m
[31m-                                    begin[m
[31m-                                        pragma Assert (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)'First = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex))'First);[m
[31m-                                        pragma Assert (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)'Length = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex))'Length);[m
[31m-                                        pragma Assert (for all I_Dex in Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))'Range => ([m
[31m-                                            Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) (I_Dex) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)) (I_Dex)[m
[31m-                                        ));[m
[31m-                                        pragma Assert_And_Cut (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) = Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)));[m
[31m-                                    end;[m
[31m-                                    pragma Assert (By ([m
[31m-                                        Generic_Sum.Sum (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = Generic_Sum.Sum (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex))),[m
[31m-                                        Generic_Sum.Lemma_Sum_Extensional (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)), Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)))[m
[31m-                                    ));[m
[31m-                                    pragma Assert_And_Cut (Generic_Sum.Sum (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = Generic_Sum.Sum (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex))));[m
[31m-                                end;[m
[31m-                                begin -- One the other side Sum of Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) equals ... , [m
[31m-                                    begin[m
[31m-                                        pragma Assert (for all I_Dex in Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))'Range => (Generic_Sum.Scalar_Mult (Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) (I_Dex) = (- Psi ** (2 * To_Big (J_Dex) + 1)) * Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex) (I_Dex)));[m
[31m-                                        pragma Assert_And_Cut (By ([m
[31m-                                            Generic_Sum.Sum (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = (- Psi ** (2 * To_Big (J_Dex) + 1)) * Generic_Sum.Sum (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)),[m
[31m-                                            Generic_Sum.Lemma_Sum_Linear_Scal_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex), Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)))[m
[31m-                                        ));[m
[31m-                                    end;[m
[31m-                                    pragma Assert (Generic_Sum.Sum (Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex)) = NTT_Ref (E_Odd, Psi_Square) (J_Dex));[m
[31m-                                    pragma Assert (Generic_Sum.Sum (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = (- Psi ** (2 * To_Big (J_Dex) + 1)) * NTT_Ref (E_Odd, Psi_Square) (J_Dex));[m
[31m-                                    pragma Assert (By (NTT_Recurs (E_Odd, Psi_Square) (J_Dex) = NTT_Ref (E_Odd, Psi_Square) (J_Dex), Lemma_Recurs_Equiv_Ref (E_Odd, Psi_Square)));[m
[31m-                                    pragma Assert_And_Cut (Generic_Sum.Sum (Generic_Sum.Scalar_Mult (- Psi ** (2 * To_Big (J_Dex) + 1), Array_Generator_Very_Inner (E_Odd, Psi_Square, J_Dex))) = (- Psi ** (2 * To_Big (J_Dex) + 1)) * NTT_Recurs (E_Odd, Psi_Square) (J_Dex));[m
[31m-                                end;[m
[32m+[m[32m                                pragma Assert (NTT_Recurs (E_Odd, Psi_Square) (J_Dex) = NTT_Ref (E_Odd, Psi_Square) (J_Dex));[m
[32m+[m[32m                                Lift4 (E_Odd, E, Psi, J_Dex);[m
                                 -- So ...[m
                                 pragma Assert_And_Cut ((- Psi ** (2 * To_Big (J_Dex) + 1)) * NTT_Recurs (E_Odd, Psi_Square) (J_Dex) = Generic_Sum.Sum (Generic_Sum.Extract_Odd (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex))));[m
                             end;[m
[36m@@ -168,14 +353,19 @@[m [mis[m
                             ,[m
                             Generic_Sum.Lemma_Split_Odd_Even (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex))[m
                         ));[m
[31m-                        pragma Assert (NTT_Ref (E, Psi) (J_Dex + Mid_Dex) = Generic_Sum.Sum (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)));[m
[32m+[m[32m                        pragma Assert[m
[32m+[m[32m                         (By (NTT_Ref (E, Psi) (J_Dex + Mid_Dex) = Generic_Sum.Sum (Array_Generator_Very_Inner (E, Psi, J_Dex + Mid_Dex)),[m
[32m+[m[32m                              NTT_Ref (E, Psi) (J_Dex + Mid_Dex) = NTT_Inner_Ref (E, Psi, 0, J_Dex + Mid_Dex)));[m
                         pragma Assert_And_Cut (NTT_Ref (E, Psi) (J_Dex + Mid_Dex) = NTT_Recurs (E, Psi) (J_Dex + Mid_Dex));[m
                     end;[m
[31m-                    pragma Loop_Invariant (for all J_Dex in 0 .. Mid_Dex - 1 => ([m
[31m-                        NTT_Recurs (E, Psi) (J_Dex) = NTT_Ref (E, Psi) (J_Dex) and [m
[31m-                        NTT_Recurs (E, Psi) (J_Dex + Mid_Dex) = NTT_Ref (E, Psi) (J_Dex + Mid_Dex)[m
[31m-                    ));[m
[32m+[m[32m                    pragma Loop_Invariant (for all I_Dex in Mid_Dex .. J_Dex + Mid_Dex =>[m[41m [m
[32m+[m[32m                        NTT_Recurs (E, Psi) (I_Dex) = NTT_Ref (E, Psi) (I_Dex)[m
[32m+[m[32m                    );[m
                 end loop;[m
[32m+[m[32m                    pragma Assert_And_Cut (for all J_Dex in Mid_Dex .. E'Length - 1 => ([m
[32m+[m[32m                        NTT_Recurs (E, Psi) (J_Dex) = NTT_Ref (E, Psi) (J_Dex)[m
[32m+[m[32m                    ));[m
[32m+[m[32m            end;[m
                 pragma Assert (NTT_Recurs (E, Psi) = NTT_Ref (E, Psi));[m
             end;[m
         end if;[m
[36m@@ -401,4 +591,4 @@[m [mis[m
 [m
 [m
 [m
[31m-end RecursNTT;[m
\ No newline at end of file[m
[32m+[m[32mend RecursNTT;[m
[1mdiff --git a/spark_ada/src/recursntt.ads b/spark_ada/src/recursntt.ads[m
[1mindex 305bb82..ea60f6b 100644[m
[1m--- a/spark_ada/src/recursntt.ads[m
[1m+++ b/spark_ada/src/recursntt.ads[m
[36m@@ -8,6 +8,26 @@[m [mpackage RecursNTT[m
     with SPARK_Mode => On[m
 is[m
 [m
[32m+[m[32m    function Square (E : Array_Zq ; Psi : T_Ref) return T_Ref[m
[32m+[m[32m        with Pre => Psi ** (To_Big_Integer (E'Length)) = - 1,[m
[32m+[m[32m            Post => Square'Result = Psi ** (To_Big_Integer (2)) and[m
[32m+[m[32m                    Square'Result ** (To_Big_Integer (E'Length / 2)) = -1;[m
[32m+[m
[32m+[m[32m   function Val_Small (E : Array_Zq; Psi : T_Ref; J_Dex : Index_Ref) return T_Ref[m[41m [m
[32m+[m[32m        with Pre => (E'Length > 1 and then Is_Pow_Of_Two (E'Length / 2)) and then[m
[32m+[m[32m                    (Psi ** To_Big_Integer (E'Length) = - 1 and[m
[32m+[m[32m                    (E'First = 0 and E'Last >= E'First and E'Length <= Integer (Index_Ref'Last + 1))) and then[m[41m  [m
[32m+[m[32m                    (Is_Pow_Of_Two (E'Length)) and then J_Dex in 0 .. Index_Ref (E'Length / 2) - 1,[m
[32m+[m[32m             Subprogram_Variant => (Decreases => E'Length, Increases => 1);[m
[32m+[m
[32m+[m[32m   function Val_Big (E : Array_Zq; Psi : T_Ref; J_Dex : Index_Ref) return T_Ref[m[41m [m
[32m+[m[32m        with Pre => (E'Length > 1 and then Is_Pow_Of_Two (E'Length / 2)) and then[m
[32m+[m[32m                    (Psi ** To_Big_Integer (E'Length) = - 1 and[m
[32m+[m[32m                    (E'First = 0 and E'Last >= E'First and E'Length <= Integer (Index_Ref'Last + 1))) and then[m[41m  [m
[32m+[m[32m                    (Is_Pow_Of_Two (E'Length)) and then J_Dex in Index_Ref (E'Length / 2) .. E'Length - 1,[m
[32m+[m[32m             Subprogram_Variant => (Decreases => E'Length, Increases => 1);[m
[32m+[m[41m      [m
[32m+[m
     --  This function is meant to be recursive[m
     function NTT_Recurs (E : Array_Zq;[m
                          Psi : T_Ref) return Array_Zq[m
[36m@@ -19,21 +39,21 @@[m [mis[m
                         NTT_Recurs'Result (0) = E (0) [m
                      else [m
                         (for all J_Dex in 0 .. Index_Ref (E'Length / 2) - 1 => ([m
[31m-                            NTT_Recurs'Result (J_Dex) = [m
[31m-                                NTT_Recurs (Generic_Sum.Extract_Even (E), Square (E, Psi)) (J_Dex) + [m
[31m-                                Psi ** (2 * To_Big (J_Dex)) * NTT_Recurs (Generic_Sum.Extract_Odd (E), Square (E, Psi)) (J_Dex) and[m
[31m-                            NTT_Recurs'Result (J_Dex + Index_Ref (E'Length / 2)) = [m
[31m-                                NTT_Recurs (Generic_Sum.Extract_Even (E), Square (E, Psi)) (J_Dex) - [m
[31m-                                Psi ** (2 * To_Big (J_Dex)) * NTT_Recurs (Generic_Sum.Extract_Odd (E), Square (E, Psi)) (J_Dex)[m
[32m+[m[32m                            NTT_Recurs'Result (J_Dex) = Val_Small (E, Psi, J_Dex))) and[m
[32m+[m[32m                        (for all J_Dex in Index_Ref (E'Length / 2) .. E'Length - 1 => ([m
[32m+[m[32m                            NTT_Recurs'Result (J_Dex) = Val_Big (E, Psi, J_Dex)[m
                         ))[m
                      ),[m
[31m-             Subprogram_Variant => (Decreases => E'Length),[m
[32m+[m[32m             Subprogram_Variant => (Decreases => E'Length, Increases => 0),[m
              Annotate => (GNATprove, Always_Return);[m
 [m
[31m-    function Square (E : Array_Zq ; Psi : T_Ref) return T_Ref[m
[31m-        with Pre => Psi ** (To_Big_Integer (E'Length)) = - 1,[m
[31m-            Post => Square'Result = Psi ** (To_Big_Integer (2)) and[m
[31m-                    Square'Result ** (To_Big_Integer (E'Length / 2)) = -1;[m
[32m+[m[32m   function Val_Small (E : Array_Zq; Psi : T_Ref; J_Dex : Index_Ref) return T_Ref is[m
[32m+[m[32m     (NTT_Recurs (Generic_Sum.Extract_Even (E), Square (E, Psi)) (J_Dex) +[m[41m [m
[32m+[m[32m          Psi ** (2 * To_Big (J_Dex) + 1) * NTT_Recurs (Generic_Sum.Extract_Odd (E), Square (E, Psi)) (J_Dex));[m
[32m+[m
[32m+[m[32m   function Val_Big (E : Array_Zq; Psi : T_Ref; J_Dex : Index_Ref) return T_Ref is[m
[32m+[m[32m     (NTT_Recurs (Generic_Sum.Extract_Even (E), Square (E, Psi)) (J_Dex - Index_Ref (E'Length / 2)) + (-[m[41m [m
[32m+[m[32m        Psi ** (2 * To_Big (J_Dex - Index_Ref (E'Length / 2)) + 1)) * NTT_Recurs (Generic_Sum.Extract_Odd (E), Square (E, Psi)) (J_Dex - Index_Ref (E'Length / 2)));[m
 [m
     function Square (E : Array_Zq ; Psi : T_Ref) return T_Ref[m
     is [m
[36m@@ -130,4 +150,4 @@[m [mis[m
              Post => Lemma_Pow_Mult'Result and[m
                      ((X ** A) ** B = X ** (A * B));[m
 [m
[31m-end RecursNTT;[m
\ No newline at end of file[m
[32m+[m[32mend RecursNTT;[m
[1mdiff --git a/spark_ada/src/refmlkem.adb b/spark_ada/src/refmlkem.adb[m
[1mindex 8e8db5b..7622a8f 100644[m
[1m--- a/spark_ada/src/refmlkem.adb[m
[1m+++ b/spark_ada/src/refmlkem.adb[m
[36m@@ -1,6 +1,18 @@[m
 package body RefMLKEM [m
     with SPARK_Mode => On[m
 is[m
[32m+[m[32m    package body ZqRef is[m
[32m+[m
[32m+[m[32m        function "**" (A : T_Ref ;[m
[32m+[m[32m                       B : Big_Natural) return T_Ref[m
[32m+[m[32m        is[m
[32m+[m[32m            (if B = 0 then 1 else A * (A ** (B - 1)));[m
[32m+[m
[32m+[m[32m        function Lemma_Pow_Def (A : T_Ref;[m
[32m+[m[32m                                B : Big_Natural) return Boolean is (True);[m
[32m+[m
[32m+[m[32m    end ZqRef;[m
[32m+[m
    function NTT_Very_Inner_Ref (E : Array_Zq; Psi : T_Ref; J : Index_Ref; I : Index_Ref) return T_Ref [m
    is (Psi ** (2 * To_Big (I) * To_Big (J) + To_Big (I) ) * E (I));[m
    --  Array_Generator_Very_Inner (E, Psi, J) (I) = NTT_Very_Inner_Ref (E, Psi, J, I)[m
[36m@@ -9,4 +21,4 @@[m [mis[m
    --  Array_Generator_Inner (E, Psi, 0) (J) = NTT_Inner_Ref (E, Psi, 0, J)[m
    function NTT_Ref (E : Array_Zq; Psi : T_Ref) return Array_Zq[m
    is (Array_Generator_Inner (E, Psi, 0));[m
[31m-end RefMLKEM;[m
\ No newline at end of file[m
[32m+[m[32mend RefMLKEM;[m
[1mdiff --git a/spark_ada/src/refmlkem.ads b/spark_ada/src/refmlkem.ads[m
[1mindex b81349b..463bee9 100644[m
[1m--- a/spark_ada/src/refmlkem.ads[m
[1m+++ b/spark_ada/src/refmlkem.ads[m
[36m@@ -30,13 +30,12 @@[m [mis[m
 [m
         function "**" (A : T_Ref;[m
                        B : Big_Natural) return T_Ref[m
[31m-            with Post => "**"'Result = (if B = 0 then 1 else A * (A ** (B - 1))),[m
[32m+[m[32m            with Post => (if B = 0 then "**"'Result = 1),[m
                  Subprogram_Variant => (Decreases => B);[m
 [m
[31m-        function "**" (A : T_Ref ;[m
[31m-                       B : Big_Natural) return T_Ref[m
[31m-        is[m
[31m-            (if B = 0 then 1 else A * (A ** (B - 1)));[m
[32m+[m[32m        function Lemma_Pow_Def (A : T_Ref;[m
[32m+[m[32m                                B : Big_Natural) return Boolean[m
[32m+[m[32m            with Post => Lemma_Pow_Def'Result and (if B > 0 then A ** B = A * (A ** (B - 1)));[m
 [m
     end ZqRef;[m
 [m
[36m@@ -63,4 +62,4 @@[m [mis[m
              Post => NTT_Ref'Result'First = E'First and NTT_Ref'Result'Last = E'Last and[m
                      NTT_Ref'Result = Array_Generator_Inner (E, Psi, 0);[m
 [m
[31m-end RefMLKEM;[m
\ No newline at end of file[m
[32m+[m[32mend RefMLKEM;[m
[1mdiff --git a/spark_ada/src/sumgen.adb b/spark_ada/src/sumgen.adb[m
[1mindex 5d5a1f5..191e9a7 100644[m
[1m--- a/spark_ada/src/sumgen.adb[m
[1m+++ b/spark_ada/src/sumgen.adb[m
[36m@@ -6,18 +6,9 @@[m [mpackage body SumGen[m
 is[m
 [m
     function Is_Pow_Of_Two (A : Positive) return Boolean[m
[31m-    is[m
[31m-        Res : Boolean;[m
[31m-    begin[m
[31m-        if A = 1 then[m
[31m-            Res := True;[m
[31m-        else[m
[31m-            pragma Assert (A / 2 >= 1);[m
[31m-            Res := A > 1 and then (A mod 2 = 0 and Is_Pow_Of_Two (A / 2));[m
[31m-        end if;[m
[31m-        pragma Assert (Res = (A = 1 or (A > 1 and then (A mod 2 = 0 and Is_Pow_Of_Two (A / 2)))));[m
[31m-        return Res;[m
[31m-    end Is_Pow_Of_Two;[m
[32m+[m[32m    is ((A = 1) or (A > 1 and then (A mod 2 = 0 and Is_Pow_Of_Two (A / 2))));[m
[32m+[m
[32m+[m[32m    function Lemma_Is_Pow_Of_Two_Def (A : Positive) return Boolean is (True);[m
 [m
     package body Sum_On_Array is [m
 [m
[36m@@ -238,4 +229,4 @@[m [mis[m
 [m
     end Sum_On_Array;[m
 [m
[31m-end SumGen;[m
\ No newline at end of file[m
[32m+[m[32mend SumGen;[m
[1mdiff --git a/spark_ada/src/sumgen.ads b/spark_ada/src/sumgen.ads[m
[1mindex f95c509..c5cf45d 100644[m
[1m--- a/spark_ada/src/sumgen.ads[m
[1m+++ b/spark_ada/src/sumgen.ads[m
[36m@@ -6,11 +6,15 @@[m [mis[m
 [m
     function Is_Pow_Of_Two (A : Positive) return Boolean[m
         with Pre => A >= 1,[m
[31m-             Post => Is_Pow_Of_Two'Result = ((A = 1) or (A > 1 and then (A mod 2 = 0 and Is_Pow_Of_Two (A / 2)))),[m
[32m+[m[32m             Post => (if Is_Pow_Of_Two'Result then (A = 1) or (A mod 2 = 0)),[m
              Subprogram_Variant =>  (Decreases => A), [m
              Annotate => (GNATprove, Always_Return);[m
 [m
[31m-    [m
[32m+[m[32m    function Lemma_Is_Pow_Of_Two_Def (A : Positive) return Boolean[m
[32m+[m[32m        with Pre => Is_Pow_Of_Two (A) and A > 1,[m
[32m+[m[32m             Post => Lemma_Is_Pow_Of_Two_Def'Result and Is_Pow_Of_Two (A / 2),[m[41m [m
[32m+[m[32m             Annotate => (GNATprove, Always_Return);[m
[32m+[m
     generic [m
         type ElementType is mod <>;[m
         type IndexRange is range <>;[m
[36m@@ -87,7 +91,7 @@[m [mis[m
         function Lemma_Sum_Linear_Scal_Mult (A : ElementType;[m
                                              B : ArrayType;[m
                                              C : ArrayType) return Boolean[m
[31m-            with Pre => B'First = C'First and B'Last = C'Last and ( [m
[32m+[m[32m            with Pre => B'First = C'First and then B'Last = C'Last and then ([m[41m [m
                         for all I in B'Range => (C (I) = A * B(I))),[m
                 Post => Lemma_Sum_Linear_Scal_Mult'Result and[m
                         Sum (C) = A * Sum (B);[m
[36m@@ -104,4 +108,4 @@[m [mis[m
                          InitialArray'Result'First = Param1'First and InitialArray'Result'Last = Param1'Last; [m
     end Sum_On_Array; [m
 [m
[31m-end SumGen;[m
\ No newline at end of file[m
[32m+[m[32mend SumGen;[m
