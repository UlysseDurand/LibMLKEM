gnatprove -Pmlkem -u src/sumgen.adb
Phase 1 of 2: generation of program properties ...
Phase 2 of 2: flow analysis and proof ...

sumgen.adb:95:53: high: range check might fail, cannot prove lower bound for A / 2
   95 |        (A = 1 or (A mod 2 = 0 and Is_Pow_Of_Two (A / 2)));
      |                                                  ~~^~~
  e.g. when A = 1
  reason for check: input value must fit in parameter type
  possible fix: add precondition (A / 2 in Positive) to subprogram at sumgen.ads:54
   54 |    function Is_Pow_Of_Two (A : Positive) return Boolean
      |             ^ here

sumgen.ads:45:38: warning: conjunct in postcondition does not check the outcome of calling "Lemma_Add_Associative"
   45 |                         (A + B) + C = A + (B + C);
      |                          ~~~~~~~~~~~^~~~~~~~~~~~

sumgen.ads:50:32: warning: conjunct in postcondition does not check the outcome of calling "Lemma_Add_Commutative"
   50 |                         A + B = B + A;
      |                         ~~~~~~^~~~~~~
Summary logged in /home/Durand/git/m1_internship/LibMLKEM/spark_ada/obj/gnatprove/gnatprove.out
gnatprove -Pmlkem -u src/mylemmas.adb
Phase 1 of 2: generation of program properties ...
Phase 2 of 2: flow analysis and proof ...
Summary logged in /home/Durand/git/m1_internship/LibMLKEM/spark_ada/obj/gnatprove/gnatprove.out
gnatprove -Pmlkem -u src/mlkem.adb
Phase 1 of 2: generation of program properties ...
Phase 2 of 2: flow analysis and proof ...
Summary logged in /home/Durand/git/m1_internship/LibMLKEM/spark_ada/obj/gnatprove/gnatprove.out
gnatprove -Pmlkem -u src/refmlkem.adb
Phase 1 of 2: generation of program properties ...
Phase 2 of 2: flow analysis and proof ...

sumgen.ads:25:51: high: range check might fail, cannot prove lower bound for A'Length - 1, in instantiation at refmlkem.adb:7
   25 |            (Partial_Sum (A, IndexRange (A'Length - 1)));
      |                                         ~~~~~~~~~^~~
  e.g. when A'First = 1
        and A'Last = 0
  reason for check: result of subtraction must be convertible to the target type of the conversion

sumgen.ads:31:83: medium: array index check might fail, in instantiation at refmlkem.adb:7
   31 |                 Post => (for all I in IndexRange => ("+"'Result (I) = F (I) + G (I)));
      |                                                                                  ^ here
  reason for check: value must be a valid index into the array

sumgen.ads:39:99: medium: precondition might fail, in instantiation at refmlkem.adb:7
   39 |                         Partial_Sum (F, Max_Index) + Partial_Sum (G, Max_Index) = Partial_Sum (F + G, Max_Index);
      |                                                                                                ~~^~~

sumgen.adb:11:38: high: array index check might fail, in instantiation at refmlkem.adb:7
   11 |        is (if Max_Index = 0 then A (0) else Partial_Sum (A, Max_Index - 1) + A (Max_Index));
      |                                     ^ here
  e.g. when A'First = 1
        and A'Last = 0
  reason for check: value must be a valid index into the array

sumgen.adb:11:82: medium: array index check might fail, in instantiation at refmlkem.adb:7
   11 |        is (if Max_Index = 0 then A (0) else Partial_Sum (A, Max_Index - 1) + A (Max_Index));
      |                                                                                 ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:18, instance at refmlkem.adb:7
   18 |        function Partial_Sum (A : InputType;
      |                 ^ here

sumgen.adb:16:13: medium: range check might fail, in instantiation at refmlkem.adb:7
   16 |            Res : InputType (0 .. F'Length) with Relaxed_Initialization;
      |            ^ here

sumgen.adb:19:31: high: array index check might fail, in instantiation at refmlkem.adb:7
   19 |                Res (I) := F (I) + G (I);
      |                              ^ here
  e.g. when F = (1 => 0)
        and F'First = 1
        and F'Last = 1
        and I = 0
  reason for check: value must be a valid index into the array

sumgen.adb:19:39: high: array index check might fail, in instantiation at refmlkem.adb:7
   19 |                Res (I) := F (I) + G (I);
      |                                      ^ here
  e.g. when G = (1 => 0)
        and G'First = 1
        and G'Last = 1
        and I = 0
  reason for check: value must be a valid index into the array

sumgen.adb:31:32: high: precondition might fail, in instantiation at refmlkem.adb:7
   31 |            H : InputType := F + G;
      |                             ~~^~~
  e.g. when F = (others => 0)
        and F'First = 0
        and F'Last = 1
        and G = (0 => 0)
        and G'First = 0
        and G'Last = 0
        and H'First = 0
        and H'Last = 0

sumgen.adb:44:56: medium: array index check might fail, in instantiation at refmlkem.adb:7
   44 |                pragma Assert (Sum_F = Tiny_Sum_F + F (Max_Index));
      |                                                       ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:46:56: medium: array index check might fail, in instantiation at refmlkem.adb:7
   46 |                pragma Assert (Sum_G = Tiny_Sum_G + G (Max_Index));
      |                                                       ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:48:56: medium: array index check might fail, in instantiation at refmlkem.adb:7
   48 |                pragma Assert (Sum_H = Tiny_Sum_H + H (Max_Index));
      |                                                       ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:54:35: medium: array index check might fail, in instantiation at refmlkem.adb:7
   54 |                pragma Assert (F (Max_Index) + G (Max_Index) = H (Max_Index));
      |                                  ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:54:51: medium: array index check might fail, in instantiation at refmlkem.adb:7
   54 |                pragma Assert (F (Max_Index) + G (Max_Index) = H (Max_Index));
      |                                                  ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:54:67: medium: array index check might fail, in instantiation at refmlkem.adb:7
   54 |                pragma Assert (F (Max_Index) + G (Max_Index) = H (Max_Index));
      |                                                                  ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:55:64: medium: array index check might fail, in instantiation at refmlkem.adb:7
   55 |                pragma Assert ((Tiny_Sum_F + Tiny_Sum_G) + (F (Max_Index) + G (Max_Index)) = Tiny_Sum_H + H (Max_Index));
      |                                                               ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:55:80: medium: array index check might fail, in instantiation at refmlkem.adb:7
   55 |                pragma Assert ((Tiny_Sum_F + Tiny_Sum_G) + (F (Max_Index) + G (Max_Index)) = Tiny_Sum_H + H (Max_Index));
      |                                                                               ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:55:110: medium: array index check might fail, in instantiation at refmlkem.adb:7
   55 |                pragma Assert ((Tiny_Sum_F + Tiny_Sum_G) + (F (Max_Index) + G (Max_Index)) = Tiny_Sum_H + H (Max_Index));
      |                                                                                                             ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:58:72: medium: array index check might fail, in instantiation at refmlkem.adb:7
   58 |                    Lemma_Add_Associative (Tiny_Sum_F + Tiny_Sum_G, F (Max_Index), G (Max_Index))
      |                                                                       ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:58:87: medium: array index check might fail, in instantiation at refmlkem.adb:7
   58 |                    Lemma_Add_Associative (Tiny_Sum_F + Tiny_Sum_G, F (Max_Index), G (Max_Index))
      |                                                                                      ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:61:132: medium: array index check might fail, in instantiation at refmlkem.adb:7
   61 |                    ((Tiny_Sum_F + Tiny_Sum_G) + F (Max_Index)) + G (Max_Index) = (Tiny_Sum_F + (Tiny_Sum_G + F (Max_Index))) + G (Max_Index),
      |                                                                                                                                   ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:62:71: medium: array index check might fail, in instantiation at refmlkem.adb:7
   62 |                    Lemma_Add_Associative (Tiny_Sum_F, Tiny_Sum_G, F (Max_Index))
      |                                                                      ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:65:129: medium: array index check might fail, in instantiation at refmlkem.adb:7
   65 |                    (Tiny_Sum_F + (Tiny_Sum_G + F (Max_Index))) + G (Max_Index) = Tiny_Sum_F + (F (Max_Index)+ Tiny_Sum_G) + G (Max_Index),
      |                                                                                                                                ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:66:47: medium: array index check might fail, in instantiation at refmlkem.adb:7
   66 |                    Lemma_Add_Commutative (F (Max_Index), Tiny_Sum_G)
      |                                              ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:69:129: medium: array index check might fail, in instantiation at refmlkem.adb:7
   69 |                    Tiny_Sum_F + (F (Max_Index)+ Tiny_Sum_G) + G (Max_Index) = ((Tiny_Sum_F + F (Max_Index)) + Tiny_Sum_G) + G (Max_Index),
      |                                                                                                                                ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:70:58: medium: array index check might fail, in instantiation at refmlkem.adb:7
   70 |                    Lemma_Add_Associative (Tiny_Sum_F, F(Max_Index), Tiny_Sum_G)
      |                                                         ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:74:60: medium: array index check might fail, in instantiation at refmlkem.adb:7
   74 |                    Lemma_Add_Associative (Tiny_Sum_F + F (Max_Index), Tiny_Sum_G, G (Max_Index))
      |                                                           ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:74:87: medium: array index check might fail, in instantiation at refmlkem.adb:7
   74 |                    Lemma_Add_Associative (Tiny_Sum_F + F (Max_Index), Tiny_Sum_G, G (Max_Index))
      |                                                                                      ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:76:49: medium: array index check might fail, in instantiation at refmlkem.adb:7
   76 |                pragma Assert ((Tiny_Sum_F + F (Max_Index))+ (Tiny_Sum_G + G (Max_Index)) = Tiny_Sum_H + H (Max_Index));
      |                                                ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:76:79: medium: array index check might fail, in instantiation at refmlkem.adb:7
   76 |                pragma Assert ((Tiny_Sum_F + F (Max_Index))+ (Tiny_Sum_G + G (Max_Index)) = Tiny_Sum_H + H (Max_Index));
      |                                                                              ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:76:109: medium: array index check might fail, in instantiation at refmlkem.adb:7
   76 |                pragma Assert ((Tiny_Sum_F + F (Max_Index))+ (Tiny_Sum_G + G (Max_Index)) = Tiny_Sum_H + H (Max_Index));
      |                                                                                                            ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at refmlkem.adb:7
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here
Summary logged in /home/Durand/git/m1_internship/LibMLKEM/spark_ada/obj/gnatprove/gnatprove.out
gnatprove -Pmlkem -u src/recursntt.adb
Phase 1 of 2: generation of program properties ...
Phase 2 of 2: flow analysis and proof ...

recursntt.adb:19:27: medium: array index check might fail
   19 |            Res (0) := E (0);
      |                          ^ here
  reason for check: value must be a valid index into the array

recursntt.adb:29:22: medium: length check might fail
   29 |                A := NTT_Recurs(Splitter.Extract_Even (E, Length), Psi * Psi, Length / 2);
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  reason for check: array must be of the appropriate length
  possible fix: precondition of subprogram at recursntt.ads:13 should mention E and Psi
   13 |    function NTT_Recurs (E : Array_Of_Zq;
      |    ^ here

recursntt.adb:30:22: medium: length check might fail
   30 |                B := NTT_Recurs(Splitter.Extract_Odd (E, Length), Psi * Psi, Length / 2);
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  reason for check: array must be of the appropriate length
  possible fix: precondition of subprogram at recursntt.ads:13 should mention E and Psi
   13 |    function NTT_Recurs (E : Array_Of_Zq;
      |    ^ here

recursntt.adb:37:16: medium: "Res" might not be initialized
   37 |        return Res;
      |               ^~~

sumgen.ads:25:51: high: range check might fail, cannot prove lower bound for A'Length - 1, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   25 |            (Partial_Sum (A, IndexRange (A'Length - 1)));
      |                                         ~~~~~~~~~^~~
  e.g. when A'First = 1
        and A'Last = 0
  reason for check: result of subtraction must be convertible to the target type of the conversion

sumgen.ads:31:83: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   31 |                 Post => (for all I in IndexRange => ("+"'Result (I) = F (I) + G (I)));
      |                                                                                  ^ here
  reason for check: value must be a valid index into the array

sumgen.ads:39:99: medium: precondition might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   39 |                         Partial_Sum (F, Max_Index) + Partial_Sum (G, Max_Index) = Partial_Sum (F + G, Max_Index);
      |                                                                                                ~~^~~

sumgen.ads:73:107: medium: array index check might fail, in instantiation at recursntt.adb:24
   73 |                 Post => (for all I in 0 .. (Length / 2 - 1) => Extract_Even'Result (IndexRange (I)) = F (IndexRange (2 * I)));
      |                                                                                                          ^~~~~~~~~~~~~~~~~
  reason for check: value must be a valid index into the array

sumgen.ads:78:106: medium: array index check might fail, in instantiation at recursntt.adb:24
   78 |                 Post => (for all I in 0 .. (Length / 2 - 1) => Extract_Odd'Result (IndexRange (I)) = F (IndexRange (2 * I + 1)));
      |                                                                                                         ^~~~~~~~~~~~~~~~~~~~~
  reason for check: value must be a valid index into the array

sumgen.ads:86:26: medium: postcondition might fail, cannot prove Summer.Sum (A) = Summer.Sum (Extract_Even (A, Length)) + Summer.Sum (Extract_Odd (A, Length)), in instantiation at recursntt.adb:24
   86 |                         Summer.Sum (A) = Summer.Sum (Extract_Even (A, Length)) + Summer.Sum (Extract_Odd (A, Length));
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sumgen.adb:11:38: high: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   11 |        is (if Max_Index = 0 then A (0) else Partial_Sum (A, Max_Index - 1) + A (Max_Index));
      |                                     ^ here
  e.g. when A'First = 1
        and A'Last = 0
  reason for check: value must be a valid index into the array

sumgen.adb:11:82: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   11 |        is (if Max_Index = 0 then A (0) else Partial_Sum (A, Max_Index - 1) + A (Max_Index));
      |                                                                                 ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:18, instance at sumgen.ads:80, instance at recursntt.adb:24
   18 |        function Partial_Sum (A : InputType;
      |                 ^ here

sumgen.adb:16:13: medium: range check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   16 |            Res : InputType (0 .. F'Length) with Relaxed_Initialization;
      |            ^ here

sumgen.adb:19:31: high: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   19 |                Res (I) := F (I) + G (I);
      |                              ^ here
  e.g. when F = (1 => 0)
        and F'First = 1
        and F'Last = 1
        and I = 0
  reason for check: value must be a valid index into the array

sumgen.adb:19:39: high: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   19 |                Res (I) := F (I) + G (I);
      |                                      ^ here
  e.g. when G = (1 => 0)
        and G'First = 1
        and G'Last = 1
        and I = 0
  reason for check: value must be a valid index into the array

sumgen.adb:31:32: high: precondition might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   31 |            H : InputType := F + G;
      |                             ~~^~~
  e.g. when F = (others => 0)
        and F'First = 0
        and F'Last = 1
        and G = (0 => 0)
        and G'First = 0
        and G'Last = 0
        and H'First = 0
        and H'Last = 0

sumgen.adb:44:56: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   44 |                pragma Assert (Sum_F = Tiny_Sum_F + F (Max_Index));
      |                                                       ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:46:56: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   46 |                pragma Assert (Sum_G = Tiny_Sum_G + G (Max_Index));
      |                                                       ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:48:56: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   48 |                pragma Assert (Sum_H = Tiny_Sum_H + H (Max_Index));
      |                                                       ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:54:35: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   54 |                pragma Assert (F (Max_Index) + G (Max_Index) = H (Max_Index));
      |                                  ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:54:51: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   54 |                pragma Assert (F (Max_Index) + G (Max_Index) = H (Max_Index));
      |                                                  ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:54:67: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   54 |                pragma Assert (F (Max_Index) + G (Max_Index) = H (Max_Index));
      |                                                                  ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:55:64: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   55 |                pragma Assert ((Tiny_Sum_F + Tiny_Sum_G) + (F (Max_Index) + G (Max_Index)) = Tiny_Sum_H + H (Max_Index));
      |                                                               ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:55:80: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   55 |                pragma Assert ((Tiny_Sum_F + Tiny_Sum_G) + (F (Max_Index) + G (Max_Index)) = Tiny_Sum_H + H (Max_Index));
      |                                                                               ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:55:110: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   55 |                pragma Assert ((Tiny_Sum_F + Tiny_Sum_G) + (F (Max_Index) + G (Max_Index)) = Tiny_Sum_H + H (Max_Index));
      |                                                                                                             ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:58:72: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   58 |                    Lemma_Add_Associative (Tiny_Sum_F + Tiny_Sum_G, F (Max_Index), G (Max_Index))
      |                                                                       ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:58:87: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   58 |                    Lemma_Add_Associative (Tiny_Sum_F + Tiny_Sum_G, F (Max_Index), G (Max_Index))
      |                                                                                      ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:61:132: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   61 |                    ((Tiny_Sum_F + Tiny_Sum_G) + F (Max_Index)) + G (Max_Index) = (Tiny_Sum_F + (Tiny_Sum_G + F (Max_Index))) + G (Max_Index),
      |                                                                                                                                   ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:62:71: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   62 |                    Lemma_Add_Associative (Tiny_Sum_F, Tiny_Sum_G, F (Max_Index))
      |                                                                      ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:65:129: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   65 |                    (Tiny_Sum_F + (Tiny_Sum_G + F (Max_Index))) + G (Max_Index) = Tiny_Sum_F + (F (Max_Index)+ Tiny_Sum_G) + G (Max_Index),
      |                                                                                                                                ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:66:47: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   66 |                    Lemma_Add_Commutative (F (Max_Index), Tiny_Sum_G)
      |                                              ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:69:129: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   69 |                    Tiny_Sum_F + (F (Max_Index)+ Tiny_Sum_G) + G (Max_Index) = ((Tiny_Sum_F + F (Max_Index)) + Tiny_Sum_G) + G (Max_Index),
      |                                                                                                                                ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:70:58: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   70 |                    Lemma_Add_Associative (Tiny_Sum_F, F(Max_Index), Tiny_Sum_G)
      |                                                         ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:74:60: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   74 |                    Lemma_Add_Associative (Tiny_Sum_F + F (Max_Index), Tiny_Sum_G, G (Max_Index))
      |                                                           ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:74:87: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   74 |                    Lemma_Add_Associative (Tiny_Sum_F + F (Max_Index), Tiny_Sum_G, G (Max_Index))
      |                                                                                      ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:76:49: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   76 |                pragma Assert ((Tiny_Sum_F + F (Max_Index))+ (Tiny_Sum_G + G (Max_Index)) = Tiny_Sum_H + H (Max_Index));
      |                                                ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:76:79: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   76 |                pragma Assert ((Tiny_Sum_F + F (Max_Index))+ (Tiny_Sum_G + G (Max_Index)) = Tiny_Sum_H + H (Max_Index));
      |                                                                              ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:76:109: medium: array index check might fail, in instantiation at sumgen.ads:80, in instantiation at recursntt.adb:24
   76 |                pragma Assert ((Tiny_Sum_F + F (Max_Index))+ (Tiny_Sum_G + G (Max_Index)) = Tiny_Sum_H + H (Max_Index));
      |                                                                                                            ^ here
  reason for check: value must be a valid index into the array
  possible fix: add precondition (Max_Index in Index_Ref) to subprogram at sumgen.ads:33, instance at sumgen.ads:80, instance at recursntt.adb:24
   33 |        function Lemma_Partial_Sum_Disjoint (F : InputType;
      |                 ^ here

sumgen.adb:106:44: high: array index check might fail, in instantiation at recursntt.adb:24
  106 |                Res (IndexRange (I)) := F (IndexRange (2 * I));
      |                                           ^~~~~~~~~~~~~~~~~
  e.g. when F'First = 1
        and F'Last = 0
        and I = 0
  reason for check: value must be a valid index into the array

sumgen.adb:121:44: high: array index check might fail, in instantiation at recursntt.adb:24
  121 |                Res (IndexRange (I)) := F (IndexRange (2 * I + 1));
      |                                           ^~~~~~~~~~~~~~~~~~~~~
  e.g. when F'First = 2
        and F'Last = 0
        and I = 0
  reason for check: value must be a valid index into the array
Summary logged in /home/Durand/git/m1_internship/LibMLKEM/spark_ada/obj/gnatprove/gnatprove.out

